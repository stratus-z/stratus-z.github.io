[{"title":"Hello World","url":"/2025/08/07/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"8.8更新日志","url":"/2025/08/08/8-8%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/","content":"2025年8月8日更新日志：\n\n部署评论系统\n\n","tags":["更新日志"]},{"title":"2025-BUAA-OOpre 反思与总结","url":"/2025/12/09/2025-BUAA-OOpre-%E5%8F%8D%E6%80%9D%E4%B8%8E%E6%80%BB%E7%BB%93/","content":"一、有关代码的总结1、作业最终的架构设计在经过一系列的迭代和调整后，本人的作业最终的架构设计为：\n\n下面我将结合这张IDEA自动生成的关系图来详细讲解我的最终架构。\n物品系统：\nItem：所有物品的接口，定义了所有物品的共同行为，Equipment和Bottle都实现了这个接口\n\nEquipment：装备类，定义了装备所具有的共同属性和共同行为\n\nWeapon：武器类，继承自Equipment\nSword：剑，继承自Weapon\nMagicbook：魔法书，继承自Weapon\n\n\nArmour：装甲类，继承自Equipment\n\n\nBottle：药水类，定义了药水所具备的共同属性和共同行为\n\nDefBottle\nManaBottle\nAtkBottle\nHpBottle\n\n\n\n法术系统：\nSpell：法术类，定义了所有法术的共同属性和行为\n\nHealSpell\nAttackSpell\n\n角色系统：\nAdventurer：冒险者类，实现了Employer和Employee两个接口，表明一个冒险者既可以是别人的雇主，也可以是别人的雇员\n基础模块：\nMainClass：处理输入，将输入处理为数组并传入Games启动游戏\nGames：核心模块，根据处理后的输入依次处理指令，并执行相关操作\nFactory：工厂类，用于创建所需的Item\nLexer：词法分析类，用于处理lr指令中操作\n程序的入口在MainClass类中，通过该类启动程序并输入操作指令，然后通过核心模块Games处理输入，调用方法，实现游戏功能。\n2、迭代中的架构调整及考虑第一次迭代此次迭代是在原有基础上为冒险者增加一些属性，并新增背包系统，丰富药水瓶的种类。因此，在这次迭代中引入了继承机制，便于对药水的管理。而对于背包系统，我则是选择在物品属性中新增Usable并添加相关管理方法，这也为后期的大重构埋下了伏笔。\n第二次迭代这次迭代加入了战斗机制，丰富了装备种类，并对背包系统进行了完善。其中，加入战斗机制只需要添加相应的方法即可，丰富装备种类也只是继承，而完善背包系统却导致了整个代码的大重构，其中很大的原因是由于第一次迭代的偷懒。这次迭代的重构我将原来用于存储所有冒险者的ArrayList容器改成了HashMap，同时在冒险者类中加入了完整的背包系统，其中的药水栏借助队列Queue实现。但在这次重构中，由于我的疏忽，并未对背包实现完整的管理，导致程序出现bug，没有通过强测。\n第三次迭代第三次迭代要求加入雇佣关系和相关限制，并引入了观察者模式。在引入雇佣关系限制的时候，最关键的一点在于异常指令判断与雇佣关系限制判断的优先级。引入的观察者模式则可以非常自然的实现救援这一过程。\n第四次迭代这次迭代只新增了lr指令，但是我们需要使用递归下降的思想来实现指令的正则化处理。在这次迭代中，我选择使用递归来实现多重关系的导入。\n二、使用JUnit的心得体会使用JUnit的目的是来测试我们自己编写的代码功能是否正常，而作业中对JUnit有着覆盖率的要求，这在很大程度上促使我们去更加全面的测试自己的代码。一方面，方法覆盖率需要我们尽可能的将所有的方法都覆盖，也就是说我们要尽可能全面的测试所有类型的指令；另一方面，分支覆盖率提醒我们要考虑到每一条指令的多种情况，这在很大程度上帮我测出了一些潜在的bug。在写JUnit测试的过程中，我也体会到，通过测试顶层的方法，它能够调用下层方法并覆盖，因此在写测试时，我们应优先测试顶层方法，然后再逐步完善测试未被覆盖的方法。同时，在编写JUnit代码中的一次重复度较高的部分，我尝试利用C语言程序简单实现了测试指令自动化转测试代码，这在一定程度上加快了我的JUnit代码的编写。\n三、学习OOPre的心得体会学习OOPre的过程并没有想象中的那么难，其关键在于编程思想的转变。之前面向过程编程侧重于算法和步骤，基本单位是函数，而面向过程编程则侧重于数据和关系，基本单位是类，这一转变让我能更好的专注于程序的功能，而不是它是怎么实现的，通过类的封装，我们只要把那些方法当成黑箱即可。\n同时，面向对象里的继承机制极大的方便了对于不同对象的处理，也更能清晰的展示不同对象之间的关系。在学习OOPre的过程中，我们也学习了一些模式如工厂模式、观察者模式等，这些不同的模式有着各自擅长处理的方法和使用场景，通过选用合适的模式，我们的程序逻辑可以更加清晰，功能也不容易出错。除此之外，面向对象的编程模式让我们更加方便添加新的功能和方法，这是因为面向对象是抽象建模的过程，在添加新功能迭代的时候，我们可以直接按照人的思维来实现。\n在编写作业程序时，我们封装了多个类，每个类各行其职，代码的整体逻辑十分明了。在编写核心程序的过程就像是搭积木，把其他类的方法按照逻辑依次调用，“拼装”成我们想要的程序。还让我感触很深的一点就是，对于之前从未接触过的Java语言，上手竟然如此容易，这也验证编程的关键不在于编程语言，而在于编程的思维。而且，借助编译器自带的代码提示工具，我们上手一门陌生编程语言的门槛越来越低。\n四、对OOPre课程的简单建议\n建议在Pre课程开始前提供一点Pre的Pre，比如简单Java程序设计，帮助大家提前适应Java编程。\n建议JUnit的教程可以再详细一点\n\n","categories":["专业课"],"tags":["OO","反思总结"]},{"title":"P3_CPU设计文档","url":"/2026/02/06/P3-CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/","content":"一、CPU设计文档（一）设计草稿本次CPU搭建需要实现的指令有add, sub, ori, lw, sw, beq, lui, nop，而CPU的构成模块有IFU, GRF, ALU, DM, EXT, Controller, NPC, Splitter，其中EXT和Splitter可以有Logisim自带的元件实现，而其他的模块则需要我们自己搭建。\n在要实现的指令中，I型指令有 ori, lw, sw, beq, lui：\n\n\n\nOpCode\nrs\nrt\nimm16\n\n\n\n6\n5\n5\n16\n\n\nR型指令有add, sub, nop：\n\n\n\nOpCode\nrs\nrt\nrd\nshamt\nFunct\n\n\n\n6\n5\n5\n5\n5\n6\n\n\n没有J型指令。\n1、IFU按照教程要求，IFU内部包括PC和IM的功能，其中PC用寄存器实现，并需要具有异步复位至0x00003000的功能，IM则要求容量为4096 × 32bit。\n对于IM，它保存的内容时待执行代码的二进制码，因此用ROM来实现，由于PC的起始地址为0x00003000，且相邻两条地址相差为4，因此地址PC与ROM中指令地址的对应关系如下：\n\n因此IM的电路为：\n\n\n对于PC，它的设计关键在于如何处理异步复位时将地址复位至0x00003000，根据逻辑表达式a ^ b ^ a = b和a ^ 0 = a，我们可以利用异或门来实现异步复位至0x00003000的操作：\n\n\n将PC和IM合并后的IFU的外观为：\n\n\n端口的说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nNPC\nI\n32\nNPC模块输出的下一条指令的地址\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n异步复位信号\n\n\nInstr\nO\n32\nIM取出的指令\n\n\nPC\nO\n32\n当前指令地址\n\n\n2、GRFGRF是通用寄存器组，其功能描述与P0时的GRF如出一辙，因此我选择调整之前P0的GRF的外观，并将其导入本次的CPU中作为现成的模块。调整后的外观为：\n\n\n端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nA1\nI\n5\n读寄存器1的地址\n\n\nA2\nI\n5\n读寄存器2的地址\n\n\nWriteAddress\nI\n5\n写入寄存器的地址\n\n\nWriteData\nI\n32\n写入寄存器的数据\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n异步复位信号\n\n\nWE\nI\n1\n写入使能信号\n\n\nRD1\nO\n32\n读寄存器1的数据\n\n\nRD2\nO\n32\n读寄存器2的数据\n\n\n3、ALUALU作为算术逻辑单元需要实现加、减、或运算和比较大小的功能，这些功能可以通过多路选择器来实现选择输出，其中比较大小功能是在输入的两个数相等时输出1，因此为其单独设计一个输出口beq。用于选择运算的ALU_op为两位，000时选择加法运算，001时选择减法运算，010时选择或运算，其他时上方out输出为x，只有beq输出，同时便于后续扩展。按照此逻辑，设计出来的ALU模块为：\n\n\n端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nin1\nI\n32\n输入待操作数1\n\n\nin2\nI\n32\n输入待操作数2\n\n\nALU_op\nI\n3\nALU控制信号\n\n\nout\nO\n32\n运算结果\n\n\nbeq\nO\n1\n两个待操作数是否相等\n\n\n4、NPCNPC模块是根据当前地址和操作，处理得到下一条指令的地址。根据相邻两条地址相差4，如果指令中没有转跳，下一条指令地址即为当前地址加4，否则，如果为beq转跳，还要加上指令跳转的相对偏移量imm16。设计出来的NPC模块外观为：\n\n\n端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nPC\nI\n32\n当前指令地址\n\n\noffset\nI\n16\n跳转的相对偏移量\n\n\nrj\nI\n1\n1表示要跳转，0表示不要\n\n\nNPC\nO\n32\n下一条指令地址\n\n\n5、DMDM模块使用了Logisim自带的RAM来实现，通过输入输出端口分离的设置来实现既读取又写入的功能，并保证了异步复位的功能。设计好后的模块为：\n\n\n端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nAddr\nI\n32\n写入或读取的地址\n\n\nWD\nI\n32\n写入的数据\n\n\nWR\nI\n1\n0表示读，1表示写\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n异步复位信号\n\n\nRD\nO\n32\n读取的数据\n\n\n6、ControllerController模块用于处理当前的指令类型，并输出控制信息，协调其他模块一起实现指令要求的功能。根据实验教程的提示，我将该模块拆分为AND_Logic模块和OR_Logic模块。其中，AND_Logic模块用于根据机器码判断当前指令是什么，而OR_Logic模块用于输出对应指令需要调用的模块信息。\nAND_Logic模块中，我使用了大量Tunnel来辅助连线，而不是像教程一样直接连线，我用_n来标记信号为原信号取反的信号，我认为这样处理可以逻辑更清晰，不易出错，且下次添加指令也较为方便。AND_Logic模块的外观为：\n\n\nOR_Logic模块则大体与教程相同，将两个模块结合起来，就形成了我们的Controller模块：\n\n\n其端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nFunct\nI\n6\n输入Instr[5:0]\n\n\nOpCode\nI\n6\n输入Instr[31:26]\n\n\nRegDst\nO\n1\nGRF写选择信号，0表示rt，1表示rd\n\n\nALUSrc\nO\n1\nALU输入信号选择，0表示in2为RD2，1表示in2为扩展后的imm16\n\n\nMemtoReg\nO\n1\nGRF输入信号选择，1表示来自DM\n\n\nRegWrite\nO\n1\nGRF写使能信号\n\n\nMemWrite\nO\n1\nDM读写使能信号\n\n\nnPC_sel\nO\n1\n1表示当前指令为beq\n\n\nExtOp\nO\n1\n扩展选择信号，0为零扩展，1为符号扩展\n\n\nALU_op\nO\n3\nALU的操作码\n\n\n（二）测试方案目前的测试方案参照实验教程，利用Mars实现程序的验证，通过Logisim和Mars同时逐步运行某一程序，并核对DM、GRF中的值是否与Mars中匹配来判断当前功能是否正确。强度更大的自动化测试还在探索中，希望能够通过自动化的程序生成强度更大的测试样例，并实现自动核对。\n二、思考题1、单周期CPU所用到的模块中，发挥状态存储功能的是PC寄存器、GRF、DM、ROM，发挥状态转移功能的是Splitter、Controller、ALU、NPC、MUX和EXT。\n2、合理。IM是指令存储器，指令一般是只读的二进制码，使用ROM可以确保指令不被修改；DM是数据存储器，既需要读也需要写，使用RAM可以满足既读又写的需求；GRF是寄存器堆，在读写时对速度要求较高，使用寄存器可以提供较高的读写速度。\n3、除上述提示模块外，我还设计了NPC模块，用于实现指令地址转移的组合逻辑。在程序中，两条相邻指令地址差为4，因此要得到下一条指令的地址，首先要将当前指令加4，如果没有出现跳转指令，则结果就是下一条指令的地址，如果当前指令为beq且需要跳转，根据指令集中对beq的操作描述，下一条指令地址为PC + 4 + sign_extend(offset||00)，利用Splitter和Bit Extender便可以实现这一操作。然后使用多路选择器，选择信号为1位的rj，表示是否需要相对跳转，来选择下一条指令的地址是否需要加上offset。\n4、nop为空指令，实际上不需要任何操作，既不会改变GRF中寄存器的值，又不需要对DM进行读写操作，我们只需要保证在指令为nop时，GRF和DM模块均不会进行写入操作，便能实现空指令行为。因此，即使不把nop加入控制信号真值表，所有的写入信号均为0，CPU并不会执行任何写入操作。\n5、这些测试样例虽然基本覆盖了要测试的指令，但还缺少sub、beq指令的测试，同时其测试强度也不足。首先，这些测试样例没有覆盖所有的极端数据，也没有覆盖所有的寄存器，情况覆盖率不够；其次，这个样例指令数量比较少，数据强度不够大，不能判断多次累计运算后功能是否还正常。\n","categories":["专业课"],"tags":["CO"]},{"title":"P6_CPU设计文档","url":"/2026/02/06/P6-CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/","content":"一、CPU设计文档（一）设计草稿本次CPU搭建需要实现的指令有：\nadd, sub, and, or, slt, sltu, luiaddi, andi, orilb, lh, lw, sb, sh, swmult, multu, div, divu, mfhi, mflo, mthi, mtlobeq, bne, jal, jr\n\n而CPU的构成模块有PC, GRF, ALU, MDU,DM_EXT, EXT, Controller, NPC, Splitter，主要是基于P5的多周期五级流水线CPU，新增指令，并实现存储器外置。\n在要实现的指令中，I型指令有 addi, andi, ori, lui, lb, lh, lw, sb, sh, sw, beq, bne：\n\n\n\nOpCode\nrs\nrt\nimm16\n\n\n\n6\n5\n5\n16\n\n\nR型指令有add, sub, and, or, slt, sltu, mult, multu, div, divu, mfhi, mflo, mthi, mtlo, nop, jr：\n\n\n\nOpCode\nrs\nrt\nrd\nshamt\nFunct\n\n\n\n6\n5\n5\n5\n5\n6\n\n\nJ型指令有jal：\n\n\n\nOpCode\nimm26\n\n\n\n6\n26\n\n\n流水线分为F（Fetch）、D（Decode）、E（Execute）、M（Memory）、W（Writeback）五级，分别表示取指阶段、译码阶段、执行阶段、存储阶段、写回阶段，每两级之间有对应的流水线寄存器来传递指令及相关数据，数据流水结构图大体为：\n\n各级大致分布和功能为：\n\n\n\n\nF\nD\nE\nM\nW\n\n\n\nA\n\n\n\n\n\n\nB\nA\n\n\n\n\n\nC\nB\nA\n\n\n\n\nD\nC\nB\nA\n\n\n\n\nD\nC\nB\nA\n\n\n\n\nD\nC\nB\n\n\n\n\n\nD\nC\n\n\n\n\n\n\nD\n\n\n流水线CPU还需要处理冒险的问题，这里用到了转发和阻塞两种方法。按照教程推荐，本人CPU使用AT法来判断是否有冒险问题，选用转发还是阻塞。首先将D、E、M、W四级分别定义为0、1、2、3级，用t_rs和t_rt来表示rs和rt寄存器的值分别会在那个级使用，t表示对应值会在那个级准备好并可以转发，用16进制f表示不会用到或产生该寄存器的值，然后分别减去对应指令当前所在级数，得到t_rs_use、t_rt_use和t_new，进行T值判断，本次包含指令对应的数据为：\nrs、rt计算型：\n\n\n\n\nadd\nsub\nand\nor\nslt\nsltu\nmult\nmultu\ndiv\ndivu\n\n\n\nt_rs\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n\n\nt_rt\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n\n\nt\n2\n2\n2\n2\n2\n2\nf\nf\nf\nf\n\n\nrs、立即数计算型：\n\n\n\n\naddi\nandi\nori\n\n\n\nt_rs\n1\n1\n1\n\n\nt_rt\nf\nf\nf\n\n\nt\n2\n2\n2\n\n\n读写内存型：\n\n\n\n\nlb\nlh\nlw\nsb\nsh\nsw\n\n\n\nt_rs\n1\n1\n1\n1\n1\n1\n\n\nt_rt\nf\nf\nf\n2\n2\n2\n\n\nt\n3\n3\n3\nf\nf\nf\n\n\n分支跳转型：\n\n\n\n\nbeq\nbne\njal\njr\n\n\n\nt_rs\n0\n0\nf\n0\n\n\nt_rt\n0\n0\nf\nf\n\n\nt\nf\nf\n0\nf\n\n\n其他：\n\n\n\n\nlui\nmfhi\nmflo\nmthi\nmtlo\n\n\n\nt_rs\nf\nf\nf\n1\n1\n\n\nt_rt\nf\nf\nf\nf\nf\n\n\nt\n2\n2\n2\nf\nf\n\n\n然后分析可以找出转发的15种情况：\n1、D_rsData来自$31且上一条为jal\twire D_rsData_from_E_PCplus8;\n2、D_rtData来自$31且上一条为jal\twire D_rtData_from_E_PCplus8;\n3、D_rsData来自$31且上上条为jal\twire D_rsData_from_M_PCplus8;\n4、D_rtData来自$31且上上条为jal\twire D_rtData_from_M_PCplus8;\n5、E_rsData来自$31且上一条为jal\twire E_rsData_from_M_PCplus8;\n6、E_rtData来自$31且上一条为jal\twire E_rtData_from_M_PCplus8;\n7、D_rsData来自上上条指令的非$31目的寄存器\twire D_rsData_from_M;\n8、D_rtData来自上上条指令的非$31目的寄存器\twire D_rtData_from_M;\n9、D_rsData来自上上上条指令的非$31目的寄存器\twire D_rsData_from_W;\n10、D_rtData来自上上上条指令的非$31目的寄存器\twire D_rtData_from_W;\n11、E_rsData来自上一条指令的非$31目的寄存器\twire E_rsData_from_M;\n12、E_rtData来自上一条指令的非$31目的寄存器\twire E_rtData_from_M;\n13、E_rsData来自上上条指令的非$31目的寄存器\twire E_rsData_from_W;\n14、E_rtData来自上上条指令的非$31目的寄存器\twire E_rtData_from_W;\n15、M_rtData来自上一条指令的非$31目的寄存器\twire M_rtData_from_W;\n然后根据对应情况设计转发控制信号和阻塞信号，实现转发和阻塞。流水线的大部分模块与P5相同，部分模块稍作改动。\n1、PC按照教程要求，原有IFU模块中的IM外置，故只剩下PC，得到对应的核心代码描述为：\nreg [31:0] regPC;always @(posedge clk) begin\tif (reset) begin\t\tregPC &lt;= 32&#x27;h3000;\tend else begin        if (PC_en) begin            regPC &lt;= NPC;        end\tendendassign PC = regPC;assign PCplus8 = regPC + 32&#x27;h8;\n\n对应模块的端口的说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nNPC\nI\n32\nF级NPC模块输出的下一条指令的地址\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n同步复位信号\n\n\nPC_en\nI\n1\nPC寄存器使能信号\n\n\nPC\nO\n32\n当前指令地址\n\n\nPCplus8\nO\n32\n延迟槽中指令的下一条指令的地址\n\n\n2、GRFGRF是通用寄存器组，与P5大体一致，删去了输出语句：\nreg [31:0] regs [0:31];integer i;always @(posedge clk) begin\tif (reset) begin\t\tfor (i = 0; i &lt; 32; i = i + 1) begin\t\t\tregs[i] &lt;= 32&#x27;h0;\t\tend\tend else begin\t\tif (WE) begin\t\t\tif (Waddr != 5&#x27;b00000) begin\t\t\t\tregs[Waddr] &lt;= WData;\t\t\tend\t\tend\tendendassign RD1 = regs[A1];assign RD2 = regs[A2];\n\n对应模块的端口的说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nPC\nI\n32\n当前指令地址\n\n\nA1\nI\n5\n读寄存器1的地址rs\n\n\nA2\nI\n5\n读寄存器2的地址rt\n\n\nWaddr\nI\n5\n写入寄存器的地址\n\n\nWData\nI\n32\n写入寄存器的数据\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n异步复位信号\n\n\nWE\nI\n1\n写入使能信号\n\n\nRD1\nO\n32\n读寄存器rs的数据\n\n\nRD2\nO\n32\n读寄存器rt的数据\n\n\n3、ALUALU作为算术逻辑单元需要实现加、减、或运算和加载立即数至高位等功能，这些功能可以通过多路选择器来实现选择输出。用于选择运算的ALU_op为四位，加入更多计算功能。按照此逻辑，原来的ALU模块可以调整为：\nparameter ADD = 4&#x27;b0000,\t\t  SUB = 4&#x27;b0001,\t\t  OR = 4&#x27;b0010,\t\t  LUI = 4&#x27;b0011,\t\t  AND = 4&#x27;b0100,\t\t  SLT = 4&#x27;b0101,\t\t  SLTU = 4&#x27;b0110;wire [31:0] Add;wire [31:0] Sub;wire [31:0] Or;wire [31:0] Lui;wire [31:0] And;wire [31:0] Slt;wire [31:0] Sltu;assign Add = in1 + in2;assign Sub = in1 - in2;assign Or = in1 | in2;assign Lui = &#123;imm16, 16&#x27;h0000&#125;;assign And = in1 &amp; in2;assign Slt = ($signed(in1) &lt; $signed(in2)) ? 32&#x27;h00000001 : 32&#x27;h00000000;assign Sltu = (in1 &lt; in2) ? 32&#x27;h00000001 : 32&#x27;h00000000;assign out = (ALU_op == ADD) ? Add :\t\t\t (ALU_op == SUB) ? Sub :\t\t\t (ALU_op == OR) ? Or :\t\t\t (ALU_op == LUI) ? Lui :\t\t\t (ALU_op == AND) ? And :\t\t\t (ALU_op == SLT) ? Slt :\t\t\t (ALU_op == SLTU) ? Sltu :\t\t\t 32&#x27;h00000000;\n\n对应端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nin1\nI\n32\n输入待操作数1\n\n\nin2\nI\n32\n输入待操作数2\n\n\nimm16\nI\n16\n输入16位立即数\n\n\nALU_op\nI\n4\nALU控制信号\n\n\nout\nO\n32\n运算结果\n\n\n4、NPCNPC模块是根据当前地址和操作，处理得到下一条指令的地址。根据相邻两条地址相差4，如果指令中没有转跳，下一条指令地址即为当前地址加4，否则，如果为beq转跳，则为当前指令地址直接加上指令跳转的相对偏移量offset，如果为绝对跳转指令，输出NPC就是绝对跳转指令的目标地址，根据此逻辑得到代码：\nwire [31:0] sign_offset;wire [31:0] adder0;wire [31:0] adder1;assign sign_offset = &#123;&#123;14&#123;offset[15]&#125;&#125;, offset, 2&#x27;b00&#125;;assign adder0 = PC + 32&#x27;h00000004;assign adder1 = PC + sign_offset;assign NPC = (jump == 1) ? dst :\t\t\t (branch == 1) ? adder1 :\t\t\t adder0;\n\n端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nPC\nI\n32\n当前指令地址\n\n\noffset\nI\n16\n跳转的相对偏移量\n\n\ndst\nI\n32\n绝对跳转的目标地址\n\n\nbranch\nI\n1\n1表示要相对跳转，0表示不要\n\n\njump\nI\n1\n1表示要绝对跳转，0表示不要\n\n\nNPC\nO\n32\n下一条指令地址\n\n\n5、DM_EXT该模块的功能是实现按字节读取的符号扩展。对应核心部分为：\nwire [7:0] Byte;wire [15:0] Half;wire [31:0] zero_Byte;wire [31:0] sign_Byte;wire [31:0] zero_Half;wire [31:0] sign_Half;assign Byte = Data_in[Addr[1:0]*8 +: 8];assign Half = Data_in[Addr[1]*16 +: 16];assign zero_Byte = &#123;24&#x27;b0, Byte&#125;;assign sign_Byte = &#123;&#123;24&#123;Byte[7]&#125;&#125;, Byte&#125;;assign zero_Half = &#123;16&#x27;b0, Half&#125;;assign sign_Half = &#123;&#123;16&#123;Half[15]&#125;&#125;, Half&#125;;assign Data_out = (load_ext_op == 3&#x27;b000) ? Data_in :                  (load_ext_op == 3&#x27;b001) ? zero_Byte :                  (load_ext_op == 3&#x27;b010) ? sign_Byte :                  (load_ext_op == 3&#x27;b011) ? zero_Half :                  (load_ext_op == 3&#x27;b100) ? sign_Half :                  32&#x27;b0;\n\n对应端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nAddr\nI\n32\n读取的地址\n\n\nData_in\nI\n32\n读取的字数据\n\n\nload_ext_op\nI\n3\n选择扩展类型\n\n\nData_out\nO\n32\n扩展后的读取数据\n\n\n6、ControllerController模块用于处理当前的指令类型，并输出控制信息和时间t_rs、t_rt、t，协调其他模块一起实现指令要求的功能。这次开发加入了新指令，控制器依然保持之前的指令型驱动的方法，在上次的指令信号对应表的基础上又添加了一些指令和信号。\n\n\n\n指令\nOpCode\nRegDst\nALUSrc\nMemtoReg\nRegWrite\nMemWrite\nbeq\nExtOp\nALU_op\njal\njr\n\n\n\nadd\n000000\n1\n0\n0\n1\n0\n0\n0\n000\n0\n0\n\n\nsub\n000000\n1\n0\n0\n1\n0\n0\n0\n001\n0\n0\n\n\nori\n001101\n0\n1\n0\n1\n0\n0\n0\n010\n0\n0\n\n\nlw\n100011\n0\n1\n1\n1\n0\n0\n1\n000\n0\n0\n\n\nsw\n101011\n0\n1\n0\n0\n1\n0\n1\n000\n0\n0\n\n\nbeq\n000100\n0\n0\n0\n0\n0\n1\n0\n001\n0\n0\n\n\nlui\n001111\n0\n0\n0\n1\n0\n0\n0\n011\n0\n0\n\n\njal\n000011\n0\n0\n0\n1\n0\n0\n0\n000\n1\n0\n\n\njr\n000000\n0\n0\n0\n0\n0\n0\n0\n000\n0\n1\n\n\n其中，部分指令还需要根据Funct来区分。基于原有的Logisim模块和Verilog语言的特点，得到实现代码，由于代码较长，这里就不展示了。\n其端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nFunct\nI\n6\n输入Instr[5:0]\n\n\nOpCode\nI\n6\n输入Instr[31:26]\n\n\nAddr\nI\n32\n输入sb、sh、sw的地址\n\n\nRegDst\nO\n1\nGRF写选择信号，0表示rt，1表示rd\n\n\nALUSrc\nO\n1\nALU输入信号选择，0表示in2为RD2，1表示in2为扩展后的imm16\n\n\nMemtoReg\nO\n1\nGRF输入数据选择信号，0表示来自ALU，1表示来自DM\n\n\nRegWrite\nO\n1\nGRF写使能信号\n\n\nMemWrite\nO\n1\nDM读写使能信号\n\n\nByteEn\nO\n4\n内存写使能信号\n\n\nExtOp\nO\n1\n扩展选择信号，0为零扩展，1为符号扩展\n\n\nload_ext_op\nO\n3\nDM_EXT操作码\n\n\nALU_op\nO\n4\nALU的操作码\n\n\nMDU_start\nO\n1\n1表示MDU运行\n\n\nMDU_read\nO\n1\n1表示读取HI或LO\n\n\nMDU_op\nO\n4\nMDU操作码\n\n\nbeq\nO\n1\n1表示当前指令为beq\n\n\nbne\nO\n1\n1表示当前指令为bne\n\n\njal\nO\n1\n1表示当前指令为jal，GRF输入数据选择为PC+4，输入地址为31，NPC输出为dst，来自imm26处理后\n\n\njr\nO\n1\n1表示当前指令为jr，NPC输出为dst，来自GRF[rs]\n\n\nsb\nO\n1\n选择输入外部存储器的数据\n\n\nsh\nO\n1\n选择输入外部存储器的数据\n\n\nt_rs\nO\n4\nrs寄存器中值在对应指令被使用的级数\n\n\nt_rt\nO\n4\nrt寄存器中值在对应指令被使用的级数\n\n\nt\nO\n4\nRegAddr对应寄存器中的新值何时可以转发\n\n\n7、CMP该模块来自原来的ALU模块，单独拆分出来是为了方便将其提前到D级，因此该模块也较为简单：\nmodule CMP(    input [31:0] in1,    input [31:0] in2,    output equal    );assign equal = (in1 == in2) ? 1&#x27;b1 : 1&#x27;b0;endmodule\n\n8、EXT该模块主要是实现符号扩展和零扩展的选择，也较为简单：\nwire [31:0] zero;wire [31:0] sign;assign zero = &#123;&#123;16&#123;1&#x27;b0&#125;&#125;, imm16&#125;;assign sign = &#123;&#123;16&#123;imm16[15]&#125;&#125;, imm16&#125;;assign imm32 = (ExtOp == 0) ? zero : sign;\n\n9、MDU该模块是用来实现乘除运算和相关寄存器的读写功能，得到的核心代码为：\nreg [31:0] HI;reg [31:0] LO;reg [3:0] counter;parameter MULT = 4&#x27;b0000,          DIV = 4&#x27;b0001,          MULTU = 4&#x27;b0010,          DIVU = 4&#x27;b0011,          MFHI = 4&#x27;b0100,          MFLO = 4&#x27;b0101,          MTHI = 4&#x27;b0110,          MTLO = 4&#x27;b0111;always @(posedge clk) begin    if (reset) begin        HI &lt;= 32&#x27;b0;        LO &lt;= 32&#x27;b0;        counter &lt;= 4&#x27;b0;    end else begin        if (start) begin            case (MDU_op)            MULT: begin                &#123;HI, LO&#125; &lt;= $signed(D1) * $signed(D2);                counter &lt;= 4&#x27;h5;            end            MULTU: begin                &#123;HI, LO&#125; &lt;= D1 * D2;                counter &lt;= 4&#x27;h5;            end            DIV: begin                LO &lt;= $signed(D1) / $signed(D2);                HI &lt;= $signed(D1) % $signed(D2);                counter &lt;= 4&#x27;ha;            end            DIVU: begin                LO &lt;= D1 / D2;                HI &lt;= D1 % D2;                counter &lt;= 4&#x27;ha;            end            MTHI: begin                HI &lt;= D1;            end            MTLO: begin                LO &lt;= D1;            end            endcase        end else begin            if (counter != 4&#x27;b0) begin                counter &lt;= counter - 4&#x27;b1;            end        end    endendassign MDU_out = (MDU_op == MFHI) ? HI :                 (MDU_op == MFLO) ? LO : 32&#x27;b0;assign busy = (counter != 4&#x27;b0) ? 1&#x27;b1 : 1&#x27;b0;\n\n相关接口说明：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nD1\nI\n32\n计算数\n\n\nD2\nI\n32\n计算数\n\n\nMDU_op\nI\n4\n操作码\n\n\nstart\nI\n1\n启动信号\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n复位信号\n\n\nMDU_out\nO\n32\n读取输出\n\n\nbusy\nO\n1\n1标志正在工作\n\n\n（二）测试方案参照实验教程，利用Mars实现程序的验证，通过ISE仿真输出和Mars运行流程，匹配仿真输出和Mars行为来判断当前功能是否正确。根据教程提供的p5_testcode.txt，将其翻译为对应的MIPS代码：\nori $0, $0, 7874ori $1, $0, 4666……nopadd $0, $29, $29sub $18, $13, $15sltu $16, $18, $18nopand $7, $16, $16label1:beq $0, $0, label1\n\n然后使用魔改版Mars进行预期输出，与Verilog仿真输出比较，在不看时间并忽略对$0写入的输出的情况下，二者输出相同，故可以初步判断CPU功能正确性。\n二、思考题1、因为乘除法运算复杂度高，简单的ALU无法满足，且乘除法运算所需周期较长，使用单独的乘除法部件可以减少阻塞流水线，尽量不影响其他非乘除法运算，提高CPU效率。采用独立的HI、LO寄存器来保存乘除法运算结果，可以在乘除法运行时减少影响其他指令的数据，减少冲突。\n2、真实的流水线CPU在运算乘法时，会将乘数与被乘数均表示为二进制，然后被乘数从低位开始每一位分别于乘数相与并左移对应位数，最后全部相加得到最终结果。在运算除法时，被除数与除数均会被表示为二进制，然后从被除数的高位开始，依次与除数比较，根据大小关系执行相应的相减和左移，并将商的对应位置数，重复多次，得到商和余数。\n3、Busy信号作为乘除模块的一种状态，当识别到D级指令需要调用乘除模块且此时乘除模块的Busy为1或者刚start，则将该指令阻塞在D级，即\nassign stall_D = (E_RegAddr != 5&#x27;d0 &amp;&amp; D_rs == E_RegAddr &amp;&amp; D_t_rs_use != 4&#x27;hf &amp;&amp; E_t_new != 4&#x27;hf &amp;&amp; D_t_rs_use &lt; E_t_new) ||\t\t\t\t (E_RegAddr != 5&#x27;d0 &amp;&amp; D_rt == E_RegAddr &amp;&amp; D_t_rt_use != 4&#x27;hf &amp;&amp; E_t_new != 4&#x27;hf &amp;&amp; D_t_rt_use &lt; E_t_new) ||\t\t\t\t (M_RegAddr != 5&#x27;d0 &amp;&amp; D_rs == M_RegAddr &amp;&amp; D_t_rs_use != 4&#x27;hf &amp;&amp; M_t_new != 4&#x27;hf &amp;&amp; D_t_rs_use &lt; M_t_new) ||\t\t\t\t (M_RegAddr != 5&#x27;d0 &amp;&amp; D_rt == M_RegAddr &amp;&amp; D_t_rt_use != 4&#x27;hf &amp;&amp; M_t_new != 4&#x27;hf &amp;&amp; D_t_rt_use &lt; M_t_new) ||\t\t\t\t (W_RegAddr != 5&#x27;d0 &amp;&amp; D_rs == W_RegAddr &amp;&amp; D_t_rs_use != 4&#x27;hf &amp;&amp; W_t_new != 4&#x27;hf &amp;&amp; D_t_rs_use &lt; W_t_new) ||\t\t\t\t (W_RegAddr != 5&#x27;d0 &amp;&amp; D_rt == W_RegAddr &amp;&amp; D_t_rt_use != 4&#x27;hf &amp;&amp; W_t_new != 4&#x27;hf &amp;&amp; D_t_rt_use &lt; W_t_new) ||\t\t\t\t (D_MDU_use &amp;&amp; (E_busy || E_MDU_start)) ? 1&#x27;b1 : 1&#x27;b0;\n\n4、在清晰性方面，使用字节使能信号，能够明确的知道哪些字节要写入，哪些字节不动，避免数据冲突；在统一性方面，字节使能信号让三种写指令的处理方式得到了统一，无需额外控制信号便可以实现32位数据所需要的写入操作。\n5、不是。当我们涉及的读写的数据均为单个字节时，按字节读写无需拆分拼接，可以直接读写，效率更高。\n6、P6的译码方式沿用了P5的方式，使用parameter为特定的二进制码命名，并使用case语句对不同指令实现特定输出信号的修改和相关t_rs、t_rt、t的赋值。使用这种方式，在译码和处理数据冲突时更加容易读懂，且条理清晰。\n7、这次实验由于新增的乘除法计算需要多个周期，导致连续的乘除法运算会出现冒险，这种情况无法通过转发解决，只能通过阻塞解决。相应的测试代码为：\nori $1, $0, 12ori $2, $0, 15ori $3, $0, 67ori $4, $0, 89mult $1, $2mult $3, $4\n\n8、选择手动构造测试数据，先测试各指令的基本功能，然后按照15条转发情况针对的设计测试样例，覆盖转发情况，接着设计样例测试阻塞的情况，覆盖对应的可能，但是由于手动构造的局限，可能仍然无法实现完全覆盖。\n","categories":["专业课"],"tags":["CO"]},{"title":"P4_CPU设计文档","url":"/2026/02/06/P4-CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/","content":"一、CPU设计文档（一）设计草稿本次CPU搭建需要实现的指令有add, sub, ori, lw, sw, beq, lui, jal, jr, nop，而CPU的构成模块有IFU, GRF, ALU, DM, EXT, Controller, NPC, Splitter，其中EXT和Splitter可以有Logisim自带的元件实现，而其他的模块则需要我们自己搭建。\n在要实现的指令中，I型指令有 ori, lw, sw, beq, lui：\n\n\n\nOpCode\nrs\nrt\nimm16\n\n\n\n6\n5\n5\n16\n\n\nR型指令有add, sub, nop, jr：\n\n\n\nOpCode\nrs\nrt\nrd\nshamt\nFunct\n\n\n\n6\n5\n5\n5\n5\n6\n\n\nJ型指令有jal：\n\n\n\nOpCode\nimm26\n\n\n\n6\n26\n\n\n1、IFU按照教程要求，IFU内部包括PC和IM的功能，其中PC用寄存器实现，并需要具有同步复位至0x00003000的功能，IM则要求容量为4096 × 32bit。\n对于IM，它保存的内容时待执行代码的二进制码，因此用ROM来实现，由于PC的起始地址为0x00003000，且相邻两条地址相差为4，因此地址PC与ROM中指令地址的对应关系与P3相同。\n基于P3的Logisim单周期CPU，结合Verilog语言，我将IFU模块翻译并简化，加入课程要求的系统导入code.txt功能，得到对应的核心代码描述为：\nreg [31:0] ROM [0:4095];reg [31:0] regPC;wire [31:0] InstrAddr;initial begin    $readmemh(&quot;code.txt&quot;, ROM, 0, 4095);endalways @(posedge clk) begin\tif (reset) begin\t\tregPC &lt;= 32&#x27;h3000;\tend else begin\t\tregPC &lt;= NPC;\tendendassign InstrAddr = PC - 32&#x27;h3000;assign Instr = ROM[InstrAddr[13:2]];assign PC = regPC;\n\n对应模块的端口的说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nNPC\nI\n32\nNPC模块输出的下一条指令的地址\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n异步复位信号\n\n\nInstr\nO\n32\nIM取出的指令\n\n\nPC\nO\n32\n当前指令地址\n\n\n2、GRFGRF是通用寄存器组，这次在P3要求的基础上将异步复位调整为了同步复位，这样也方便了Verilog的书写，利用Verilog中的寄存器数组便可以轻松实现：\nreg [31:0] regs [0:31];integer i;always @(posedge clk) begin\tif (reset) begin\t\tfor (i = 0; i &lt; 32; i = i + 1) begin\t\t\tregs[i] &lt;= 32&#x27;h0;\t\tend\tend else begin\t\tif (WE) begin\t\t\tif (A3 != 5&#x27;b00000) begin\t\t\t\tregs[A3] &lt;= WD;\t\t\tend\t\tend\tendendassign RD1 = regs[A1];assign RD2 = regs[A2];\n\n对应模块的端口的说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nPC\nI\n32\n用于输出\n\n\nA1\nI\n5\n读寄存器1的地址rs\n\n\nA2\nI\n5\n读寄存器2的地址rt\n\n\nWaddr\nI\n5\n写入寄存器的地址\n\n\nWData\nI\n32\n写入寄存器的数据\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n异步复位信号\n\n\nWE\nI\n1\n写入使能信号\n\n\nRD1\nO\n32\n读寄存器rs的数据\n\n\nRD2\nO\n32\n读寄存器rt的数据\n\n\n3、ALUALU作为算术逻辑单元需要实现加、减、或运算和比较大小的功能，这些功能可以通过多路选择器来实现选择输出，其中比较大小功能是在输入的两个数相等时输出1，因此为其单独设计一个输出口beq。用于选择运算的ALU_op为两位，000时选择加法运算，001时选择减法运算，010时选择或运算，其他时上方out输出为32&#39;h00000000，表示不需要用到上方输出，同时便于后续扩展。按照此逻辑，原来的ALU模块可以翻译为：\nparameter ADD = 3&#x27;b000,\t\t  SUB = 3&#x27;b001,\t\t  OR = 3&#x27;b010;wire [31:0] Add;wire [31:0] Sub;wire [31:0] Or;assign Add = in1 + in2;assign Sub = in1 - in2;assign Or = in1 | in2;assign out = (ALU_op == ADD) ? Add :\t\t\t (ALU_op == SUB) ? Sub :\t\t\t (ALU_op == OR) ? Or:\t\t\t 32&#x27;h00000000;assign equal = (in1 == in2) ? 1 : 0;\n\n对应端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nin1\nI\n32\n输入待操作数1\n\n\nin2\nI\n32\n输入待操作数2\n\n\nALU_op\nI\n3\nALU控制信号\n\n\nout\nO\n32\n运算结果\n\n\nequal\nO\n1\n两个待操作数是否相等\n\n\n4、NPCNPC模块是根据当前地址和操作，处理得到下一条指令的地址。根据相邻两条地址相差4，如果指令中没有转跳，下一条指令地址即为当前地址加4，否则，如果为beq转跳，还要加上指令跳转的相对偏移量offset，如果为绝对跳转指令，输出NPC就是绝对跳转指令的目标地址，根据此逻辑得到代码：\nwire [31:0] sign_offset;wire [31:0] adder0;wire [31:0] adder1;assign sign_offset = &#123;&#123;16&#123;offset[15]&#125;&#125;, offset&#125;;\t//符号扩展assign adder0 = PC + 32&#x27;h00000004;assign adder1 = adder0 + sign_offset;assign NPC = (j == 1) ? dst :    (rj == 1) ? adder1 :\t\t\t adder0;\n\n端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nPC\nI\n32\n当前指令地址\n\n\noffset\nI\n16\n跳转的相对偏移量\n\n\ndst\nI\n32\n绝对跳转的目标地址\n\n\nrj\nI\n1\n1表示要相对跳转，0表示不要\n\n\nj\nI\n1\n1表示要绝对跳转，0表示不要\n\n\nNPC\nO\n32\n下一条指令地址\n\n\n5、DMDM模块与IM部分类似，依旧使用寄存器数组来实现。与Logisim中不同的是，Verilog中只需要控制信号来控制是否写入即可，输出可以一直保持，同时将复位调整为同步复位便可以完成。对应核心部分为：\nreg [31:0] RAM [0:4095];integer i;always @(posedge clk) begin\tif (reset) begin\t\tfor (i = 0; i &lt; 4096; i = i + 1) begin\t\t\tRAM[i] &lt;= 32&#x27;h0;\t\tend\tend else begin\t\tif (WR) begin\t\t\tRAM[Addr[13:2]] &lt;= WD;\t\tend\tendendassign RD = RAM[Addr[13:2]];\n\n对应端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nPC\nI\n32\n用于输出\n\n\nAddr\nI\n32\n写入或读取的地址\n\n\nWD\nI\n32\n写入的数据\n\n\nWR\nI\n1\n0表示读，1表示写\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n异步复位信号\n\n\nRD\nO\n32\n读取的数据\n\n\n6、ControllerController模块用于处理当前的指令类型，并输出控制信息，协调其他模块一起实现指令要求的功能。根据指令集和相关指令的功能，得到一张输入输出关系对应表：\n\n\n\n指令\nOpCode\nRegDst\nALUSrc\nMemtoReg\nRegWrite\nMemWrite\nbeq\nExtOp\nALU_op\nlui\njal\njr\n\n\n\nadd\n000000\n1\n0\n0\n1\n0\n0\n0\n000\n0\n0\n0\n\n\nsub\n000000\n1\n0\n0\n1\n0\n0\n0\n001\n0\n0\n0\n\n\nori\n001101\n0\n1\n0\n1\n0\n0\n0\n010\n0\n0\n0\n\n\nlw\n100011\n0\n1\n1\n1\n0\n0\n1\n000\n0\n0\n0\n\n\nsw\n101011\n0\n1\n0\n0\n1\n0\n1\n000\n0\n0\n0\n\n\nbeq\n000100\n0\n0\n0\n0\n0\n1\n0\n001\n0\n0\n0\n\n\nlui\n001111\n0\n0\n0\n1\n0\n0\n0\n000\n1\n0\n0\n\n\njal\n000011\n0\n0\n0\n1\n0\n0\n0\n000\n0\n1\n0\n\n\njr\n000000\n0\n0\n0\n0\n0\n0\n0\n000\n0\n0\n1\n\n\n其中，add（100000 ）、sub（100010）和jr（001000）还需要根据Funct来区分。基于原有的Logisim模块和Verilog语言的特点，得到实现代码：\n其端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nFunct\nI\n6\n输入Instr[5:0]\n\n\nOpCode\nI\n6\n输入Instr[31:26]\n\n\nRegDst\nO\n1\nGRF写选择信号，0表示rt，1表示rd\n\n\nALUSrc\nO\n1\nALU输入信号选择，0表示in2为RD2，1表示in2为扩展后的imm16\n\n\nMemtoReg\nO\n1\nGRF输入数据选择信号，0表示来自ALU，1表示来自DM\n\n\nRegWrite\nO\n1\nGRF写使能信号\n\n\nMemWrite\nO\n1\nDM读写使能信号\n\n\nbeq\nO\n1\n1表示当前指令为beq\n\n\nExtOp\nO\n1\n扩展选择信号，0为零扩展，1为符号扩展\n\n\nALU_op\nO\n3\nALU的操作码\n\n\nlui\nO\n1\n1表示当前指令为lui，GRF输入数据选择为imm16加载至高位\n\n\njal\nO\n1\n1表示当前指令为jal，GRF输入数据选择为PC+4，输入地址为31，NPC输出为dst，来自imm26处理后\n\n\njr\nO\n1\n1表示当前指令为jr，NPC输出为dst，来自GRF[rs]\n\n\n（二）测试方案参照实验教程，利用Mars实现程序的验证，通过ISE仿真输出和Mars运行流程，匹配仿真输出和Mars行为来判断当前功能是否正确。根据教程提供的p4_testcode.txt，将其翻译为对应的MIPS代码：\n.textori $28, $0, 0ori $29, $0, 0ori $1, $0, 13398add $1, $1, $1lw $1, 4($0)sw $1, 4($0)lui $2, 30840sub $3, $2, $1lui $5, 4660ori $4, $0, 5nopsw $5, -1($4)lw $3, -1($4)beq $3, $5, label1nopbeq $0, $0, label2noplabel1:ori $7, $3, 1028beq $7, $3, label2noplui $8, 30583ori $8, $8, 65535sub $0, $0, $8ori $0, $0, 4352add $10, $7, $6ori $8, $0, 0ori $9, $0, 1ori $10, $0, 1label3:add $8, $8, $10beq $8, $9, label3jal label4nopadd $10, $10, $10label2:beq $0, $0, label2label4:add $10, $10, $10jr $31nop\n\n经过对比，Verilog仿真输出与Mars的行为相符，故可知CPU功能大体正确。\n二、思考题1、这个addr信号来自ALU的输出ALU_out。地址信号 addr 位数是 [11:2] 而不是 [9:0]是因为DM容量为12KiB（3072 × 32bit），而且DM中是按字索引，ALU_out需要除以4即右移2位才可得到DM中的地址索引，故直接省去低两位来代替右移，即对应位数为[11:2]。\n2、第一种记录指令对应的控制信号如何取值的实现：\nRegDst = 1&#x27;b0;ALUSrc = 1&#x27;b0;MemtoReg = 1&#x27;b0;RegWrite = 1&#x27;b0;MemWrite = 1&#x27;b0;beq = 1&#x27;b0;ExtOp = 1&#x27;b0;ALU_op = 3&#x27;b000;lui = 1&#x27;b0;jal = 1&#x27;b0;jr = 1&#x27;b0;case(OpCode)\tFUNCT: begin\t\tcase(Funct)\t\t\tADD: begin\t\t\t\tRegDst = 1&#x27;b1;\t\t\t\tRegWrite = 1&#x27;b1;\t\t\tend\t\t\tSUB: begin\t\t\t\tRegDst = 1&#x27;b1;\t\t\t\tRegWrite = 1&#x27;b1;\t\t\t\tALU_op = 3&#x27;b001;\t\t\tend\t\t\tJR: begin\t\t\t\tjr = 1&#x27;b1;\t\t\tend\t\tendcase\tend\tORI: begin\t\tALUSrc = 1&#x27;b1;\t\tRegWrite = 1&#x27;b1;\t\tALU_op = 3&#x27;b010;\tend\tLW: begin\t\tALUSrc = 1&#x27;b1;\t\tMemtoReg = 1&#x27;b1;\t\tRegWrite = 1&#x27;b1;\t\tExtOp = 1&#x27;b1;\tend\tSW: begin\t\tALUSrc = 1&#x27;b1;\t\tMemWrite = 1&#x27;b1;\t\tExtOp = 1&#x27;b1;\tend\tBEQ: begin\t\tbeq = 1&#x27;b1;\t\tALU_op = 3&#x27;b001;\tend\tLUI: begin\t\tRegWrite = 1&#x27;b1;\t\tlui = 1&#x27;b1;\tend\tJAL: begin\t\tRegWrite = 1&#x27;b1;\t\tjal = 1&#x27;b1;\tendendcase\n\n第二种记录控制信号每种取值所对应的指令的实现：\nRegDst = 1&#x27;b0;ALUSrc = 1&#x27;b0;MemtoReg = 1&#x27;b0;RegWrite = 1&#x27;b0;MemWrite = 1&#x27;b0;beq = 1&#x27;b0;ExtOp = 1&#x27;b0;ALU_op = 3&#x27;b000;lui = 1&#x27;b0;jal = 1&#x27;b0;jr = 1&#x27;b0;Add = 0;Sub = 0;Ori = 0;Lw = 0;Sw = 0;Beq = 0;Lui = 0;Jal = 0;Jr = 0;case(OpCode)\tFUNCT: begin\t\tcase(Funct)\t\t\tADD: begin\t\t\t\tAdd = 1;\t\t\tend\t\t\tSUB: begin\t\t\t\tSub = 1;\t\t\tend\t\t\tJR: begin\t\t\t\tJr = 1;\t\t\tend\t\tendcase\tend\tORI: begin\t\tOri = 1;\tend\tLW: begin\t\tLw = 1;\tend\tSW: begin\t\tSw = 1;\tend\tBEQ: begin\t\tBeq = 1;\tend\tLUI: begin\t\tLui = 1;\tend\tJAL: begin\t\tJal = 1;\tendendcaseRegDst = Add | Sub;ALUSrc = Ori | Lw | Sw;MemtoReg = Lw;RegWrite = Add | Sub | Ori | Lw | Lui | Jal;MemWrite = Sw;beq = Beq;ExtOp = Lw | Sw;ALU_op = (Add | Lw | Sw | Lui | Jal | Jr) ? 3&#x27;b000 :\t\t (Sub | Beq) ? 3&#x27;b001 : 3&#x27;b010;lui = Lui;jal = Jal;jr = Jr;\n\n对于第一种方法，可以方便地追踪各指令的控制信号配置，便于调试和扩展新指令；但一旦添加了新的控制信号，就需要修改所有指令的取值配置，维护起来比较繁琐。\n对于第二种方法，可以更直观地了解控制信号的构成，方便添加新的控制信号；不过在增加新指令时，就需要在多个地方修改，容易遗漏，从而引入 bug。\n3、同步复位中，clk信号优先级比reset高，reset信号只有在时钟上升沿才有效；异步复位中，reset信号与clk信号优先级相同，reset信号在任何时刻都有效。\n4、通过对比addi与addiu、add与addu的Operation部分可以发现，二者的主要区别在于溢出处理：addi和add在发生溢出时会触发Integer Overflow异常，而addiu和addu则不会。如果仅需支持C语言程序，那么可以不考虑溢出异常，此时addi与addiu可以视为等价，add与addu也同样等价。\n","categories":["专业课"],"tags":["CO"]},{"title":"P5_CPU设计文档","url":"/2026/02/06/P5-CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/","content":"一、CPU设计文档（一）设计草稿本次CPU搭建需要实现的指令有add, sub, ori, lw, sw, beq, lui, jal, jr, nop，而CPU的构成模块有IFU, GRF, ALU, DM, EXT, Controller, NPC, Splitter，主要时基于P4的单周期CPU，将其改装为多周期五级流水线CPU，并实现延迟槽功能。\n在要实现的指令中，I型指令有 ori, lw, sw, beq, lui：\n\n\n\nOpCode\nrs\nrt\nimm16\n\n\n\n6\n5\n5\n16\n\n\nR型指令有add, sub, nop, jr：\n\n\n\nOpCode\nrs\nrt\nrd\nshamt\nFunct\n\n\n\n6\n5\n5\n5\n5\n6\n\n\nJ型指令有jal：\n\n\n\nOpCode\nimm26\n\n\n\n6\n26\n\n\n流水线分为F（Fetch）、D（Decode）、E（Execute）、M（Memory）、W（Writeback）五级，分别表示取指阶段、译码阶段、执行阶段、存储阶段、写回阶段，每两级之间有对应的流水线寄存器来传递指令及相关数据，数据流水结构图大体为：\n\n各级大致分布和功能为：\n\n\n\n\nF\nD\nE\nM\nW\n\n\n\nA\n\n\n\n\n\n\nB\nA\n\n\n\n\n\nC\nB\nA\n\n\n\n\nD\nC\nB\nA\n\n\n\n\nD\nC\nB\nA\n\n\n\n\nD\nC\nB\n\n\n\n\n\nD\nC\n\n\n\n\n\n\nD\n\n\n单周期CPU配合流水线寄存器改为多周期CPU后，还需要处理冒险的问题，这里用到了转发和阻塞两种方法。按照教程推荐，本人CPU使用AT法来判断是否有冒险问题，选用转发还是阻塞。首先将D、E、M、W四级分别定义为0、1、2、3级，用t_rs和t_rt来表示rs和rt寄存器的值分别会在那个级使用，t表示对应值会在那个级准备好并可以转发，用16进制f表示不会用到或产生该寄存器的值，然后分别减去对应指令当前所在级数，得到t_rs_use、t_rt_use和t_new，进行T值判断，本次添加指令对应的数据为：\n\n\n\n\nadd\nsub\nori\nlw\nsw\nbeq\nlui\njal\njr\nnop\n\n\n\nt_rs\n1\n1\n1\n1\n1\n0\nf\nf\n0\nf\n\n\nt_rt\n1\n1\nf\nf\n2\n0\nf\nf\nf\nf\n\n\nt\n2\n2\n2\n3\nf\nf\n2\n0\nf\nf\n\n\n然后分析可以找出转发的15种情况：\n1、D_rsData来自$31且上一条为jal\twire D_rsData_from_E_PCplus8;\n2、D_rtData来自$31且上一条为jal\twire D_rtData_from_E_PCplus8;\n3、D_rsData来自$31且上上条为jal\twire D_rsData_from_M_PCplus8;\n4、D_rtData来自$31且上上条为jal\twire D_rtData_from_M_PCplus8;\n5、E_rsData来自$31且上一条为jal\twire E_rsData_from_M_PCplus8;\n6、E_rtData来自$31且上一条为jal\twire E_rtData_from_M_PCplus8;\n7、D_rsData来自上上条指令的非$31目的寄存器\twire D_rsData_from_M;\n8、D_rtData来自上上条指令的非$31目的寄存器\twire D_rtData_from_M;\n9、D_rsData来自上上上条指令的非$31目的寄存器\twire D_rsData_from_W;\n10、D_rtData来自上上上条指令的非$31目的寄存器\twire D_rtData_from_W;\n11、E_rsData来自上一条指令的非$31目的寄存器\twire E_rsData_from_M;\n12、E_rtData来自上一条指令的非$31目的寄存器\twire E_rtData_from_M;\n13、E_rsData来自上上条指令的非$31目的寄存器\twire E_rsData_from_W;\n14、E_rtData来自上上条指令的非$31目的寄存器\twire E_rtData_from_W;\n15、M_rtData来自上一条指令的非$31目的寄存器\twire M_rtData_from_W;\n然后根据对应情况设计转发控制信号和阻塞信号，实现转发和阻塞。流水线的大部分模块与单周期时相同，部分模块稍作改动。\n1、IFU按照教程要求，IFU内部包括PC和IM的功能，其中PC用寄存器实现，并需要具有同步复位至0x00003000的功能，IM则要求容量为4096 × 32bit。\n对于IM，它保存的内容时待执行代码的二进制码，因此用ROM来实现，由于PC的起始地址为0x00003000，且相邻两条地址相差为4，因此地址PC与ROM中指令地址的对应关系如下：\n\n基于P3的Logisim单周期CPU，结合Verilog语言，我将IFU模块翻译并简化，加入课程要求的系统导入code.txt功能，得到对应的核心代码描述为：\nreg [31:0] ROM [0:4095];reg [31:0] regPC;wire [31:0] InstrAddr;initial begin    $readmemh(&quot;code.txt&quot;, ROM, 0, 4095);endalways @(posedge clk) begin\tif (reset) begin\t\tregPC &lt;= 32&#x27;h3000;\tend else begin        if (PC_en) begin            regPC &lt;= NPC;        end\tendendassign InstrAddr = PC - 32&#x27;h3000;assign Instr = ROM[InstrAddr[13:2]];assign PC = regPC;assign PCplus8 = regPC + 32&#x27;h8;\n\n对应模块的端口的说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nNPC\nI\n32\nF级NPC模块输出的下一条指令的地址\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n同步复位信号\n\n\nInstr\nO\n32\nIM取出的指令\n\n\nPC\nO\n32\n当前指令地址\n\n\nPCplus8\nO\n32\n延迟槽中指令的下一条指令的地址\n\n\n2、GRFGRF是通用寄存器组，这次在P4要求的基础上在输出种增加了时间：\nreg [31:0] regs [0:31];integer i;always @(posedge clk) begin\tif (reset) begin\t\tfor (i = 0; i &lt; 32; i = i + 1) begin\t\t\tregs[i] &lt;= 32&#x27;h0;\t\tend\tend else begin\t\tif (WE) begin\t\t\t$display(&quot;%d@%h: $%d &lt;= %h&quot;, $time, PC, Waddr, WData);\t\t\tif (Waddr != 5&#x27;b00000) begin\t\t\t\tregs[Waddr] &lt;= WData;\t\t\tend\t\tend\tendendassign RD1 = regs[A1];assign RD2 = regs[A2];\n\n对应模块的端口的说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nPC\nI\n32\n用于输出\n\n\nA1\nI\n5\n读寄存器1的地址rs\n\n\nA2\nI\n5\n读寄存器2的地址rt\n\n\nWaddr\nI\n5\n写入寄存器的地址\n\n\nWData\nI\n32\n写入寄存器的数据\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n异步复位信号\n\n\nWE\nI\n1\n写入使能信号\n\n\nRD1\nO\n32\n读寄存器rs的数据\n\n\nRD2\nO\n32\n读寄存器rt的数据\n\n\n3、ALUALU作为算术逻辑单元需要实现加、减、或运算和加载立即数至高位的功能，这些功能可以通过多路选择器来实现选择输出。用于选择运算的ALU_op为两位，000时选择加法运算，001时选择减法运算，010时选择或运算，011时选择加载至高位，其他时上方out输出为32&#39;h00000000，表示不需要用到上方输出，同时便于后续扩展。按照此逻辑，原来的ALU模块可以调整为：\nparameter ADD = 3&#x27;b000,\t\t  SUB = 3&#x27;b001,\t\t  OR = 3&#x27;b010,\t\t  LUI = 3&#x27;b011;wire [31:0] Add;wire [31:0] Sub;wire [31:0] Or;wire [31:0] Lui;assign Add = in1 + in2;assign Sub = in1 - in2;assign Or = in1 | in2;assign Lui = &#123;imm16, 16&#x27;h0000&#125;;assign out = (ALU_op == ADD) ? Add :\t\t\t (ALU_op == SUB) ? Sub :\t\t\t (ALU_op == OR) ? Or :\t\t\t (ALU_op == LUI) ? Lui :\t\t\t 32&#x27;h00000000;\n\n对应端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nin1\nI\n32\n输入待操作数1\n\n\nin2\nI\n32\n输入待操作数2\n\n\nimm16\nI\n16\n输入16位立即数\n\n\nALU_op\nI\n3\nALU控制信号\n\n\nout\nO\n32\n运算结果\n\n\n4、NPCNPC模块是根据当前地址和操作，处理得到下一条指令的地址。根据相邻两条地址相差4，如果指令中没有转跳，下一条指令地址即为当前地址加4，否则，如果为beq转跳，则为当前指令地址直接加上指令跳转的相对偏移量offset，如果为绝对跳转指令，输出NPC就是绝对跳转指令的目标地址，根据此逻辑得到代码：\nwire [31:0] sign_offset;wire [31:0] adder0;wire [31:0] adder1;assign sign_offset = &#123;&#123;14&#123;offset[15]&#125;&#125;, offset, 2&#x27;b00&#125;;assign adder0 = PC + 32&#x27;h00000004;assign adder1 = PC + sign_offset;assign NPC = (jump == 1) ? dst :\t\t\t (branch == 1) ? adder1 :\t\t\t adder0;\n\n端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nPC\nI\n32\n当前指令地址\n\n\noffset\nI\n16\n跳转的相对偏移量\n\n\ndst\nI\n32\n绝对跳转的目标地址\n\n\nbranch\nI\n1\n1表示要相对跳转，0表示不要\n\n\njump\nI\n1\n1表示要绝对跳转，0表示不要\n\n\nNPC\nO\n32\n下一条指令地址\n\n\n5、DMDM模块与IM部分类似，依旧使用寄存器数组来实现，输出较P4增加时间。对应核心部分为：\nreg [31:0] RAM [0:3071];integer i;always @(posedge clk) begin\tif (reset) begin\t\tfor (i = 0; i &lt; 3072; i = i + 1) begin\t\t\tRAM[i] &lt;= 32&#x27;h0;\t\tend\tend else begin\t\tif (WR) begin\t\t\t$display(&quot;%d@%h: *%h &lt;= %h&quot;, $time, PC, Addr, WD);\t\t\tRAM[Addr[13:2]] &lt;= WD;\t\tend\tendendassign RD = RAM[Addr[13:2]];\n\n对应端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nPC\nI\n32\n用于输出对应指令地址\n\n\nAddr\nI\n32\n写入或读取的地址\n\n\nWD\nI\n32\n写入的数据\n\n\nWR\nI\n1\n0表示读，1表示写\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n异步复位信号\n\n\nRD\nO\n32\n读取的数据\n\n\n6、ControllerController模块用于处理当前的指令类型，并输出控制信息，协调其他模块一起实现指令要求的功能。在这个基础上，该模块还新增了时间t_rs、t_rt、t的输出。根据指令集和相关指令的功能，得到一张控制信号输入输出关系对应表：\n\n\n\n指令\nOpCode\nRegDst\nALUSrc\nMemtoReg\nRegWrite\nMemWrite\nbeq\nExtOp\nALU_op\njal\njr\n\n\n\nadd\n000000\n1\n0\n0\n1\n0\n0\n0\n000\n0\n0\n\n\nsub\n000000\n1\n0\n0\n1\n0\n0\n0\n001\n0\n0\n\n\nori\n001101\n0\n1\n0\n1\n0\n0\n0\n010\n0\n0\n\n\nlw\n100011\n0\n1\n1\n1\n0\n0\n1\n000\n0\n0\n\n\nsw\n101011\n0\n1\n0\n0\n1\n0\n1\n000\n0\n0\n\n\nbeq\n000100\n0\n0\n0\n0\n0\n1\n0\n001\n0\n0\n\n\nlui\n001111\n0\n0\n0\n1\n0\n0\n0\n011\n0\n0\n\n\njal\n000011\n0\n0\n0\n1\n0\n0\n0\n000\n1\n0\n\n\njr\n000000\n0\n0\n0\n0\n0\n0\n0\n000\n0\n1\n\n\n其中，add（100000 ）、sub（100010）和jr（001000）还需要根据Funct来区分。基于原有的Logisim模块和Verilog语言的特点，得到实现代码：\n其端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nFunct\nI\n6\n输入Instr[5:0]\n\n\nOpCode\nI\n6\n输入Instr[31:26]\n\n\nRegDst\nO\n1\nGRF写选择信号，0表示rt，1表示rd\n\n\nALUSrc\nO\n1\nALU输入信号选择，0表示in2为RD2，1表示in2为扩展后的imm16\n\n\nMemtoReg\nO\n1\nGRF输入数据选择信号，0表示来自ALU，1表示来自DM\n\n\nRegWrite\nO\n1\nGRF写使能信号\n\n\nMemWrite\nO\n1\nDM读写使能信号\n\n\nbeq\nO\n1\n1表示当前指令为beq\n\n\nExtOp\nO\n1\n扩展选择信号，0为零扩展，1为符号扩展\n\n\nALU_op\nO\n3\nALU的操作码\n\n\njal\nO\n1\n1表示当前指令为jal，GRF输入数据选择为PC+4，输入地址为31，NPC输出为dst，来自imm26处理后\n\n\njr\nO\n1\n1表示当前指令为jr，NPC输出为dst，来自GRF[rs]\n\n\nt_rs\nO\n4\nrs寄存器中值在对应指令被使用的级数\n\n\nt_rt\nO\n4\nrt寄存器中值在对应指令被使用的级数\n\n\nt\nO\n4\nRegAddr对应寄存器中的新值何时可以转发\n\n\n7、CMP该模块来自原来的ALU模块，单独拆分出来是为了方便将其提前到D级，因此该模块也较为简单：\nmodule CMP(    input [31:0] in1,    input [31:0] in2,    output equal    );assign equal = (in1 == in2) ? 1&#x27;b1 : 1&#x27;b0;endmodule\n\n8、EXT该模块主要是实现符号扩展和零扩展的选择，也较为简单：\nwire [31:0] zero;wire [31:0] sign;assign zero = &#123;&#123;16&#123;1&#x27;b0&#125;&#125;, imm16&#125;;assign sign = &#123;&#123;16&#123;imm16[15]&#125;&#125;, imm16&#125;;assign imm32 = (ExtOp == 0) ? zero : sign;\n\n（二）测试方案参照实验教程，利用Mars实现程序的验证，通过ISE仿真输出和Mars运行流程，匹配仿真输出和Mars行为来判断当前功能是否正确。根据教程提供的p5_testcode.txt，将其翻译为对应的MIPS代码：\n.textori $28, $0, 0ori $29, $0, 0ori $1, $0, 4112lui $2, 34595ori $3, $0, 30806lui $4, 34303ori $5, $0, 1lui $6, 65535ori $7, $0, 65535add $1, $1, $2add $9, $1, $3sub $8, $1, $2sub $0, $7, $0beq $28, $17, label1nopbeq $0, $0, label2noplabel1:beq $1, $2, label2nopori $2, $0, 12nopnopnopjal label3sw $1, 0($2)beq $0, $0, label2add $1, $1, $2label3:add $1, $1, $2add $1, $1, $2add $1, $1, $2sw $31, 0($2)lw $1, 0($2)nopnopnopjr $1sw $31, 0($2)label2:beq $0, $0, label2nop\n\n然后使用魔改版Mars进行预期输出，与Verilog仿真输出比较，在不看时间并忽略对$0写入的输出的情况下，二者输出均为：\n@00003000: $28 &lt;= 00000000@00003004: $29 &lt;= 00000000@00003008: $ 1 &lt;= 00001010@0000300c: $ 2 &lt;= 87230000@00003010: $ 3 &lt;= 00007856@00003014: $ 4 &lt;= 85ff0000@00003018: $ 5 &lt;= 00000001@0000301c: $ 6 &lt;= ffff0000@00003020: $ 7 &lt;= 0000ffff@00003024: $ 1 &lt;= 87231010@00003028: $ 9 &lt;= 87238866@0000302c: $ 8 &lt;= 00001010@0000304c: $ 2 &lt;= 0000000c@0000305c: $31 &lt;= 00003064@00003060: *0000000c &lt;= 87231010@0000306c: $ 1 &lt;= 8723101c@00003070: $ 1 &lt;= 87231028@00003074: $ 1 &lt;= 87231034@00003078: *0000000c &lt;= 00003064@0000307c: $ 1 &lt;= 00003064@00003090: *0000000c &lt;= 00003064@00003068: $ 1 &lt;= 00003070\n\n由此可以初步判断，CPU的功能正常。\n二、思考题1、提前分支判断会引入新的数据冒险，因为提起分支判断后分支跳转指令的t_use为0，如果对应寄存器在E、M、W的t_new大于0，则出现了必须阻塞的冒险，导致效率降低。指令序列的例子：\nadd $1, $2, $3beq $1, $0, label\n\n2、由于延迟槽的存在，jal等需要将指令地址写入寄存器的指令在D级译码后才会得到跳转信号，此时F级中的指令地址为D_PC+4，如果将该地址存入寄存器，后续返回该地址时会回到已执行过的延迟槽中的指令，这是不对等，正确的写入地址应该为F_PC+4，也就是D_PC+8，所以要写回PC+8。\n3、所有转发数据都来源于流水寄存器而不能是功能部件的原因是功能部件的输出有延迟，可能导致接收到的转发数据不稳定，造成错误，使用流水线寄存器的数据，是上一个周期已经计算好的，输出稳定，可以保证数据的正确性。\n4、使用GPR内部转发是因为GPR既是D级的部件，又是W级的部件，基于这一特性，我们可以使用内部转发实现将W级数据转发到D级，避免D级使用错误数据。具体的实现方式为：\nassign D_rsData_from_W = (W_RegWrite &amp;&amp; W_RegAddr != 5&#x27;d0 &amp;&amp; D_rs == W_RegAddr &amp;&amp; W_t_new != 4&#x27;hf &amp;&amp; D_t_rs_use != 4&#x27;hf &amp;&amp; D_t_rs_use &gt;= W_t_new) ? 1&#x27;b1 : 1&#x27;b0;assign D_rtData_from_W = (W_RegWrite &amp;&amp; W_RegAddr != 5&#x27;d0 &amp;&amp; D_rt == W_RegAddr &amp;&amp; W_t_new != 4&#x27;hf &amp;&amp; D_t_rt_use != 4&#x27;hf &amp;&amp; D_t_rt_use &gt;= W_t_new) ? 1&#x27;b1 : 1&#x27;b0;\n\n5、转发时数据的需求者可能来自D级的CMP（D_rsData和D_rtData）、E级的ALU（E_rsData和E_rtData）、M级的DM（M_rtData），供给者可能来自E级和M级的PC+8、M级的M_ALU_out、W级的W_RegData。转发通路可以细分为15条：\nwire D_rsData_from_E_PCplus8;wire D_rtData_from_E_PCplus8;wire D_rsData_from_M_PCplus8;wire D_rtData_from_M_PCplus8;wire E_rsData_from_M_PCplus8;wire E_rtData_from_M_PCplus8;wire D_rsData_from_M;wire D_rtData_from_M;wire D_rsData_from_W;wire D_rtData_from_W;wire E_rsData_from_M;wire E_rtData_from_M;wire E_rsData_from_W;wire E_rtData_from_W;wire M_rtData_from_W;\n\n6、计算指令：首先修改ALU模块，使其能够满足新增指令的计算要求，然后修改Controller，处理指令的OpCode和Funct，在新增指令的case块中按要求设置相应的控制信号，并输出对应的t_rs、t_rt和t，其他数据通路基本不需要修改。\n跳转指令：对于条件跳转指令，在D级中加入相关条件的判断，然后在Controller中新增并修改相关控制信号和时间输出，两个信号结合在D级中输给D_jump信号，数据通路基本不变。对于无条件跳转指令，首先修改Controller中相关控制信号和时间输出，对于需要链接的，还要将RegWrite输出置为1，并新增对应的控制信号在D级中选择链接的寄存器地址。\n访存指令：首先修改Controller，让其能够处理新增指令的控制信号和时间输出，对于访问指令，利用控制信号在M级中处理得到需要访问的地址，而对于存储指令，则需要利用控制信号在M级中处理存储的地址和数据。\n7、我的译码方式为分布式译码，译码器架构为指令驱动型，利用case语句对不同指令的控制信号实现赋值。这种架构的优点是在新增指令时不需要将控制信号流水到每一级，只需要在用到的级译码使用，添加新指令方便，但缺点是新增指令时需要修改的地方较多，整体代码量会随指令数量增多而显著增大，同时也增加了流水线的逻辑复杂度。\n","categories":["专业课"],"tags":["CO"]},{"title":"P7_CPU设计文档","url":"/2026/02/06/P7-CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/","content":"一、CPU设计文档（一）设计草稿本次CPU搭建需要实现的指令有：\nadd, sub, and, or, slt, sltu, luiaddi, andi, orilb, lh, lw, sb, sh, swmult, multu, div, divu, mfhi, mflo, mthi, mtlobeq, bne, jal, jrmfc0, mtc0, eret, syscall\n\n而CPU的构成模块有PC, GRF, ALU, MDU,DM_EXT, EXT, Controller, NPC, Splitter, CP0，主要是基于P6的多周期五级流水线CPU，新增异常中断处理。\n在要实现的指令中，I型指令有 addi, andi, ori, lui, lb, lh, lw, sb, sh, sw, beq, bne：\n\n\n\nOpCode\nrs\nrt\nimm16\n\n\n\n6\n5\n5\n16\n\n\nR型指令有add, sub, and, or, slt, sltu, mult, multu, div, divu, mfhi, mflo, mthi, mtlo, nop, jr：\n\n\n\nOpCode\nrs\nrt\nrd\nshamt\nFunct\n\n\n\n6\n5\n5\n5\n5\n6\n\n\nJ型指令有jal：\n\n\n\nOpCode\nimm26\n\n\n\n6\n26\n\n\n设计的mips顶层模块的结构大体为：\n\n流水线分为F（Fetch）、D（Decode）、E（Execute）、M（Memory）、W（Writeback）五级，分别表示取指阶段、译码阶段、执行阶段、存储阶段、写回阶段，每两级之间有对应的流水线寄存器来传递指令及相关数据，数据流水结构图大体为：\n\n各级大致分布和功能为：\n\n\n\n\nF\nD\nE\nM\nW\n\n\n\nA\n\n\n\n\n\n\nB\nA\n\n\n\n\n\nC\nB\nA\n\n\n\n\nD\nC\nB\nA\n\n\n\n\nD\nC\nB\nA\n\n\n\n\nD\nC\nB\n\n\n\n\n\nD\nC\n\n\n\n\n\n\nD\n\n\n该CPU使用AT法来判断是否有冒险问题，选用转发还是阻塞。首先将D、E、M、W四级分别定义为0、1、2、3级，用t_rs和t_rt来表示rs和rt寄存器的值分别会在那个级使用，t表示对应值会在那个级准备好并可以转发，用16进制f表示不会用到或产生该寄存器的值，然后分别减去对应指令当前所在级数，得到t_rs_use、t_rt_use和t_new，进行T值判断，本次包含指令对应的数据为：\nrs、rt计算型：\n\n\n\n\nadd\nsub\nand\nor\nslt\nsltu\nmult\nmultu\ndiv\ndivu\n\n\n\nt_rs\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n\n\nt_rt\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n\n\nt\n2\n2\n2\n2\n2\n2\nf\nf\nf\nf\n\n\nrs、立即数计算型：\n\n\n\n\naddi\nandi\nori\n\n\n\nt_rs\n1\n1\n1\n\n\nt_rt\nf\nf\nf\n\n\nt\n2\n2\n2\n\n\n读写内存型：\n\n\n\n\nlb\nlh\nlw\nsb\nsh\nsw\n\n\n\nt_rs\n1\n1\n1\n1\n1\n1\n\n\nt_rt\nf\nf\nf\n2\n2\n2\n\n\nt\n3\n3\n3\nf\nf\nf\n\n\n分支跳转型：\n\n\n\n\nbeq\nbne\njal\njr\n\n\n\nt_rs\n0\n0\nf\n0\n\n\nt_rt\n0\n0\nf\nf\n\n\nt\nf\nf\n0\nf\n\n\n其他：\n\n\n\n\nlui\nmfhi\nmflo\nmthi\nmtlo\n\n\n\nt_rs\nf\nf\nf\n1\n1\n\n\nt_rt\nf\nf\nf\nf\nf\n\n\nt\n2\n2\n2\nf\nf\n\n\n然后分析可以找出转发的15种情况：\n1、D_rsData来自$31且上一条为jal\twire D_rsData_from_E_PCplus8;\n2、D_rtData来自$31且上一条为jal\twire D_rtData_from_E_PCplus8;\n3、D_rsData来自$31且上上条为jal\twire D_rsData_from_M_PCplus8;\n4、D_rtData来自$31且上上条为jal\twire D_rtData_from_M_PCplus8;\n5、E_rsData来自$31且上一条为jal\twire E_rsData_from_M_PCplus8;\n6、E_rtData来自$31且上一条为jal\twire E_rtData_from_M_PCplus8;\n7、D_rsData来自上上条指令的非$31目的寄存器\twire D_rsData_from_M;\n8、D_rtData来自上上条指令的非$31目的寄存器\twire D_rtData_from_M;\n9、D_rsData来自上上上条指令的非$31目的寄存器\twire D_rsData_from_W;\n10、D_rtData来自上上上条指令的非$31目的寄存器\twire D_rtData_from_W;\n11、E_rsData来自上一条指令的非$31目的寄存器\twire E_rsData_from_M;\n12、E_rtData来自上一条指令的非$31目的寄存器\twire E_rtData_from_M;\n13、E_rsData来自上上条指令的非$31目的寄存器\twire E_rsData_from_W;\n14、E_rtData来自上上条指令的非$31目的寄存器\twire E_rtData_from_W;\n15、M_rtData来自上一条指令的非$31目的寄存器\twire M_rtData_from_W;\n在以上CPU的基础上需要实现Bridge功能来连接CPU与DM、timer0、timer1和外设，由于timer相关模块课程组已经给出，只需要看懂后实例化即可，这一部分并不难。下面是CPU中的各模块的介绍：\n1、PC与P6保持相同，对应的核心代码描述为：\nreg [31:0] regPC;always @(posedge clk) begin\tif (reset) begin\t\tregPC &lt;= 32&#x27;h3000;\tend else begin        if (PC_en) begin            regPC &lt;= NPC;        end\tendendassign PC = regPC;assign PCplus8 = regPC + 32&#x27;h8;\n\n对应模块的端口的说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nNPC\nI\n32\nF级NPC模块输出的下一条指令的地址\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n同步复位信号\n\n\nPC_en\nI\n1\nPC寄存器使能信号\n\n\nPC\nO\n32\n当前指令地址\n\n\nPCplus8\nO\n32\n延迟槽中指令的下一条指令的地址\n\n\n2、GRFGRF是通用寄存器组，与P6一致：\nreg [31:0] regs [0:31];integer i;always @(posedge clk) begin\tif (reset) begin\t\tfor (i = 0; i &lt; 32; i = i + 1) begin\t\t\tregs[i] &lt;= 32&#x27;h0;\t\tend\tend else begin\t\tif (WE) begin\t\t\tif (Waddr != 5&#x27;b00000) begin\t\t\t\tregs[Waddr] &lt;= WData;\t\t\tend\t\tend\tendendassign RD1 = regs[A1];assign RD2 = regs[A2];\n\n对应模块的端口的说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nPC\nI\n32\n当前指令地址\n\n\nA1\nI\n5\n读寄存器1的地址rs\n\n\nA2\nI\n5\n读寄存器2的地址rt\n\n\nWaddr\nI\n5\n写入寄存器的地址\n\n\nWData\nI\n32\n写入寄存器的数据\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n异步复位信号\n\n\nWE\nI\n1\n写入使能信号\n\n\nRD1\nO\n32\n读寄存器rs的数据\n\n\nRD2\nO\n32\n读寄存器rt的数据\n\n\n3、ALU在P6基础上加入了溢出信号和异常信号判断ExcCode的输出。按照此逻辑，原来的ALU模块可以调整为：\nparameter ADD = 4&#x27;b0000,\t\t  SUB = 4&#x27;b0001,\t\t  OR = 4&#x27;b0010,\t\t  LUI = 4&#x27;b0011,\t\t  AND = 4&#x27;b0100,\t\t  SLT = 4&#x27;b0101,\t\t  SLTU = 4&#x27;b0110,\t\t  NOP = 4&#x27;b1111;wire [31:0] Add;wire [31:0] Sub;wire [31:0] Or;wire [31:0] Lui;wire [31:0] And;wire [31:0] Slt;wire [31:0] Sltu;wire [32:0] add_temp;wire [32:0] sub_temp;wire overflow;assign Add = in1 + in2;assign Sub = in1 - in2;assign Or = in1 | in2;assign Lui = &#123;imm16, 16&#x27;h0000&#125;;assign And = in1 &amp; in2;assign Slt = ($signed(in1) &lt; $signed(in2)) ? 32&#x27;h00000001 : 32&#x27;h00000000;assign Sltu = (in1 &lt; in2) ? 32&#x27;h00000001 : 32&#x27;h00000000;assign out = (ALU_op == ADD) ? Add :\t\t\t (ALU_op == SUB) ? Sub :\t\t\t (ALU_op == OR) ? Or :\t\t\t (ALU_op == LUI) ? Lui :\t\t\t (ALU_op == AND) ? And :\t\t\t (ALU_op == SLT) ? Slt :\t\t\t (ALU_op == SLTU) ? Sltu :\t\t\t 32&#x27;h00000000;assign add_temp = &#123;in1[31], in1&#125; + &#123;in2[31], in2&#125;;assign sub_temp = &#123;in1[31], in1&#125; - &#123;in2[31], in2&#125;;assign overflow = (ALU_op == ADD) ? (add_temp[32] ^ add_temp[31]) :\t\t\t\t  (ALU_op == SUB) ? (sub_temp[32] ^ sub_temp[31]) :\t\t\t\t  1&#x27;b0;assign ExcCode = ((lb || lh || lw) &amp;&amp; overflow) ? 5&#x27;d4 :\t\t\t\t (lw &amp;&amp; (out[1:0] != 2&#x27;b00)) ? 5&#x27;d4 : \t\t\t\t (lh &amp;&amp; (out[0] != 1&#x27;b0)) ? 5&#x27;d4 :\t\t\t\t (lw &amp;&amp; !((out &gt;= 32&#x27;h00000000 &amp;&amp; out &lt; 32&#x27;h00003000) ||\t\t\t\t \t\t  (out &gt;= 32&#x27;h00007f00 &amp;&amp; out &lt; 32&#x27;h00007f0c) ||\t\t\t\t \t\t  (out &gt;= 32&#x27;h00007f10 &amp;&amp; out &lt; 32&#x27;h00007f1c) ||\t\t\t\t\t\t  (out &gt;= 32&#x27;h00007f20 &amp;&amp; out &lt; 32&#x27;h00007f24))) ? 5&#x27;d4 :\t\t\t\t ((lb || lh) &amp;&amp; !((out &gt;= 32&#x27;h00000000 &amp;&amp; out &lt; 32&#x27;h00003000) ||\t\t\t\t \t\t\t\t  (out &gt;= 32&#x27;h00007f20 &amp;&amp; out &lt; 32&#x27;h00007f24))) ? 5&#x27;d4 :\t\t\t\t //store address error\t\t\t\t ((sb || sh || sw) &amp;&amp; overflow) ? 5&#x27;d5 :\t\t\t\t (sw &amp;&amp; (out[1:0] != 2&#x27;b00)) ? 5&#x27;d5 :\t\t\t\t (sh &amp;&amp; (out[0] != 1&#x27;b0)) ? 5&#x27;d5 :\t\t\t\t (sw &amp;&amp; !((out &gt;= 32&#x27;h00000000 &amp;&amp; out &lt; 32&#x27;h00003000) ||\t\t\t\t \t\t  (out &gt;= 32&#x27;h00007f00 &amp;&amp; out &lt; 32&#x27;h00007f08) ||\t\t\t\t\t\t  (out &gt;= 32&#x27;h00007f10 &amp;&amp; out &lt; 32&#x27;h00007f18) ||\t\t\t\t\t\t  (out &gt;= 32&#x27;h00007f20 &amp;&amp; out &lt; 32&#x27;h00007f24))) ? 5&#x27;d5 :\t\t\t\t ((sb || sh) &amp;&amp; !((out &gt;= 32&#x27;h00000000 &amp;&amp; out &lt; 32&#x27;h00003000) ||\t\t\t\t \t\t\t\t  (out &gt;= 32&#x27;h00007f20 &amp;&amp; out &lt; 32&#x27;h00007f24))) ? 5&#x27;d5 :\t\t\t\t //arithmetic overflow\t\t\t\t (overflow_cal &amp;&amp; overflow) ? 5&#x27;d12 :\t\t\t\t 5&#x27;d0;\n\n对应端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nin1\nI\n32\n输入待操作数1\n\n\nin2\nI\n32\n输入待操作数2\n\n\nimm16\nI\n16\n输入16位立即数\n\n\nlb\nI\n1\n标志指令为lb\n\n\nlh\nI\n1\n标志指令为lh\n\n\nlw\nI\n1\n标志指令为lw\n\n\nsb\nI\n1\n标志指令为sb\n\n\nsh\nI\n1\n标志指令为sh\n\n\nsw\nI\n1\n标志指令为sw\n\n\noverflow_cal\nI\n1\n标志指令为可能出现算术溢出的指令\n\n\nALU_op\nI\n4\nALU控制信号\n\n\nout\nO\n32\n运算结果\n\n\n4、NPCNPC模块是根据当前地址和操作，处理得到下一条指令的地址。根据相邻两条地址相差4，如果指令中没有转跳，下一条指令地址即为当前地址加4，否则，如果为beq转跳，则为当前指令地址直接加上指令跳转的相对偏移量offset，如果为绝对跳转指令，输出NPC就是绝对跳转指令的目标地址。同时，当识别到指令为异常指令或出现外部中断时，将NPC置为0x4180，根据此逻辑得到代码：\nwire [31:0] sign_offset;wire [31:0] adder0;wire [31:0] adder1;assign sign_offset = &#123;&#123;14&#123;offset[15]&#125;&#125;, offset, 2&#x27;b00&#125;;assign adder0 = PC + 32&#x27;h00000004;assign adder1 = PC + sign_offset;assign NPC = (Req) ? 32&#x27;h00004180 :\t\t//the entry point\t\t\t (jump == 1) ? dst :\t\t\t (branch == 1) ? adder1 :\t\t\t adder0;\n\n端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nPC\nI\n32\n当前指令地址\n\n\noffset\nI\n16\n跳转的相对偏移量\n\n\ndst\nI\n32\n绝对跳转的目标地址\n\n\nbranch\nI\n1\n1表示要相对跳转，0表示不要\n\n\njump\nI\n1\n1表示要绝对跳转，0表示不要\n\n\nReq\nI\n1\n1表示要陷入内核\n\n\nNPC\nO\n32\n下一条指令地址\n\n\n5、DM_EXT该模块的功能是实现按字节读取的符号扩展。对应核心部分为：\nwire [7:0] Byte;wire [15:0] Half;wire [31:0] zero_Byte;wire [31:0] sign_Byte;wire [31:0] zero_Half;wire [31:0] sign_Half;assign Byte = Data_in[Addr[1:0]*8 +: 8];assign Half = Data_in[Addr[1]*16 +: 16];assign zero_Byte = &#123;24&#x27;b0, Byte&#125;;assign sign_Byte = &#123;&#123;24&#123;Byte[7]&#125;&#125;, Byte&#125;;assign zero_Half = &#123;16&#x27;b0, Half&#125;;assign sign_Half = &#123;&#123;16&#123;Half[15]&#125;&#125;, Half&#125;;assign Data_out = (load_ext_op == 3&#x27;b000) ? Data_in :                  (load_ext_op == 3&#x27;b001) ? zero_Byte :                  (load_ext_op == 3&#x27;b010) ? sign_Byte :                  (load_ext_op == 3&#x27;b011) ? zero_Half :                  (load_ext_op == 3&#x27;b100) ? sign_Half :                  32&#x27;b0;\n\n对应端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nAddr\nI\n32\n读取的地址\n\n\nData_in\nI\n32\n读取的字数据\n\n\nload_ext_op\nI\n3\n选择扩展类型\n\n\nData_out\nO\n32\n扩展后的读取数据\n\n\n6、ControllerController模块用于处理当前的指令类型，并输出控制信息和时间t_rs、t_rt、t，协调其他模块一起实现指令要求的功能。这次开发加入了新指令，控制器依然保持之前的指令型驱动的方法，在上次的指令信号对应表的基础上又添加了一些指令和信号，并能输出指令是否为未知指令。\n\n\n\n指令\nOpCode\nRegDst\nALUSrc\nMemtoReg\nRegWrite\nMemWrite\nbeq\nExtOp\nALU_op\njal\njr\n\n\n\nadd\n000000\n1\n0\n0\n1\n0\n0\n0\n000\n0\n0\n\n\nsub\n000000\n1\n0\n0\n1\n0\n0\n0\n001\n0\n0\n\n\nori\n001101\n0\n1\n0\n1\n0\n0\n0\n010\n0\n0\n\n\nlw\n100011\n0\n1\n1\n1\n0\n0\n1\n000\n0\n0\n\n\nsw\n101011\n0\n1\n0\n0\n1\n0\n1\n000\n0\n0\n\n\nbeq\n000100\n0\n0\n0\n0\n0\n1\n0\n001\n0\n0\n\n\nlui\n001111\n0\n0\n0\n1\n0\n0\n0\n011\n0\n0\n\n\njal\n000011\n0\n0\n0\n1\n0\n0\n0\n000\n1\n0\n\n\njr\n000000\n0\n0\n0\n0\n0\n0\n0\n000\n0\n1\n\n\n其中，部分指令还需要根据Funct来区分。基于原有的Logisim模块和Verilog语言的特点，得到实现代码，由于代码较长，这里就不展示了。\n其端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nInstr\nI\n32\n输入Instr\n\n\nAddr\nI\n32\n输入sb、sh、sw的地址\n\n\nRegDst\nO\n1\nGRF写选择信号，0表示rt，1表示rd\n\n\nALUSrc\nO\n1\nALU输入信号选择，0表示in2为RD2，1表示in2为扩展后的imm16\n\n\nMemtoReg\nO\n1\nGRF输入数据选择信号，0表示来自ALU，1表示来自DM\n\n\nRegWrite\nO\n1\nGRF写使能信号\n\n\nMemWrite\nO\n1\nDM读写使能信号\n\n\nByteEn\nO\n4\n内存写使能信号\n\n\nExtOp\nO\n1\n扩展选择信号，0为零扩展，1为符号扩展\n\n\nload_ext_op\nO\n3\nDM_EXT操作码\n\n\nALU_op\nO\n4\nALU的操作码\n\n\nMDU_start\nO\n1\n1表示MDU运行多个周期\n\n\nMDU_write\nO\n1\n1表示指令需要写入HI或LO\n\n\nMDU_read\nO\n1\n1表示读取HI或LO\n\n\nMDU_op\nO\n4\nMDU操作码\n\n\nbeq\nO\n1\n1表示当前指令为beq\n\n\nbne\nO\n1\n1表示当前指令为bne\n\n\njal\nO\n1\n1表示当前指令为jal，GRF输入数据选择为PC+4，输入地址为31，NPC输出为dst，来自imm26处理后\n\n\njr\nO\n1\n1表示当前指令为jr，NPC输出为dst，来自GRF[rs]\n\n\nlb\nO\n1\n1表示指令为lb\n\n\nlh\nO\n1\n1表示指令为lh\n\n\nlw\nO\n1\n1表示指令为lw\n\n\nsb\nO\n1\n1表示指令为sb\n\n\nsh\nO\n1\n1表示指令为sh\n\n\nsw\nO\n1\n1表示指令为sw\n\n\nmft0\nO\n1\n1表示指令为mfc0\n\n\nmtc0\nO\n1\n1表示指令为mtc0\n\n\neret\nO\n1\n1表示指令为eret\n\n\nsyscall\nO\n1\n1表示指令为syscall\n\n\nt_rs\nO\n4\nrs寄存器中值在对应指令被使用的级数\n\n\nt_rt\nO\n4\nrt寄存器中值在对应指令被使用的级数\n\n\nt\nO\n4\nRegAddr对应寄存器中的新值何时可以转发\n\n\nerror\nO\n1\n1表示指令为未知指令\n\n\noverflow_cal\nO\n1\n1表示指令为可能发生算术溢出的指令\n\n\n7、CMP该模块来自原来的ALU模块，单独拆分出来是为了方便将其提前到D级，因此该模块也较为简单：\nmodule CMP(    input [31:0] in1,    input [31:0] in2,    output equal    );assign equal = (in1 == in2) ? 1&#x27;b1 : 1&#x27;b0;endmodule\n\n8、EXT该模块主要是实现符号扩展和零扩展的选择，也较为简单：\nwire [31:0] zero;wire [31:0] sign;assign zero = &#123;&#123;16&#123;1&#x27;b0&#125;&#125;, imm16&#125;;assign sign = &#123;&#123;16&#123;imm16[15]&#125;&#125;, imm16&#125;;assign imm32 = (ExtOp == 0) ? zero : sign;\n\n9、MDU该模块是用来实现乘除运算和相关寄存器的读写功能，在P7中加入Req控制暂停，得到的核心代码为：\nreg [31:0] HI;reg [31:0] LO;reg [3:0] counter;parameter MULT = 4&#x27;b0000,          DIV = 4&#x27;b0001,          MULTU = 4&#x27;b0010,          DIVU = 4&#x27;b0011,          MFHI = 4&#x27;b0100,          MFLO = 4&#x27;b0101,          MTHI = 4&#x27;b0110,          MTLO = 4&#x27;b0111;always @(posedge clk) begin    if (reset) begin        HI &lt;= 32&#x27;b0;        LO &lt;= 32&#x27;b0;        counter &lt;= 4&#x27;b0;    end else begin        if (~Req) begin            if (write) begin                case (MDU_op)                MULT: begin                    &#123;HI, LO&#125; &lt;= $signed(D1) * $signed(D2);                    counter &lt;= 4&#x27;h5;                end                MULTU: begin                    &#123;HI, LO&#125; &lt;= D1 * D2;                    counter &lt;= 4&#x27;h5;                end                DIV: begin                    LO &lt;= $signed(D1) / $signed(D2);                    HI &lt;= $signed(D1) % $signed(D2);                    counter &lt;= 4&#x27;ha;                end                DIVU: begin                    LO &lt;= D1 / D2;                    HI &lt;= D1 % D2;                    counter &lt;= 4&#x27;ha;                end                MTHI: begin                    HI &lt;= D1;                end                MTLO: begin                    LO &lt;= D1;                end                endcase            end            if (counter != 4&#x27;b0) begin                counter &lt;= counter - 4&#x27;b1;            end        end    endendassign MDU_out = (MDU_op == MFHI) ? HI :                 (MDU_op == MFLO) ? LO : 32&#x27;b0;assign busy = (counter != 4&#x27;b0) ? 1&#x27;b1 : 1&#x27;b0;\n\n相关接口说明：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nD1\nI\n32\n计算数\n\n\nD2\nI\n32\n计算数\n\n\nMDU_op\nI\n4\n操作码\n\n\nstart\nI\n1\n启动信号\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n复位信号\n\n\nReq\nI\n1\n控制是否要暂停\n\n\nMDU_out\nO\n32\n读取输出\n\n\nbusy\nO\n1\n1标志正在工作\n\n\n10、CP0该模块为本次新增模块，用于处理内部指令异常和外部中断。其中有三个寄存器SR、Cause、EPC，分别负责配置异常的功能、记录异常发生的原因和情况、记录异常处理结束后需要返回的PC，根据其功能，得到其核心代码：\nreg [31:0] SR;      // 12reg [31:0] Cause;   // 13reg [31:0] EPC;     // 14reg [31:0] PRId;    // 15always @(posedge clk) begin    if (reset) begin        SR &lt;= 32&#x27;h00000000;        Cause &lt;= 32&#x27;h00000000;        EPC &lt;= 32&#x27;h00000000;        PRId &lt;= 32&#x27;h24373025;   //ID    end else begin        if (en &amp;&amp; ~Req) begin            //mtc0            case (CP0_Addr)                5&#x27;d12: SR &lt;= CP0_In;                5&#x27;d14: EPC &lt;= CP0_In;            endcase        end else begin            if (Req) begin                //exception occurs                //set EXL                `SR_EXL &lt;= 1&#x27;b1;                //set Cause                `CAUSE_BD &lt;= BD_In;                `CAUSE_ExcCode &lt;= (~`SR_EXL &amp;&amp; `SR_IE &amp;&amp; (`SR_IM &amp; HWInt)) ? 5&#x27;b0 : ExcCode_In;                //set EPC                EPC &lt;= (BD_In) ? VPC - 32&#x27;d4 : VPC;            end        end        `CAUSE_IP &lt;= HWInt;        if (EXL_Clr) begin            `SR_EXL &lt;= 1&#x27;b0;        end    endendassign CP0_Out = (CP0_Addr == 5&#x27;d12) ? SR :                 (CP0_Addr == 5&#x27;d13) ? Cause :                 (CP0_Addr == 5&#x27;d14) ? EPC :                 (CP0_Addr == 5&#x27;d15) ? PRId :                 32&#x27;b0;assign EPC_Out = EPC;assign Req = (~`SR_EXL &amp;&amp; ((`SR_IE &amp;&amp; (`SR_IM &amp; HWInt)) || ExcCode_In));\n\n对应接口说明：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n复位信号\n\n\nen\nI\n1\n写寄存器使能\n\n\nCP0_Addr\nI\n5\n写寄存器地址\n\n\nCP0_In\nI\n32\n写寄存器数据\n\n\nCP0_Out\nO\n32\n读寄存器数据\n\n\nVPC\nI\n32\n受害指令地址\n\n\nBD_In\nI\n1\n1表示为延迟槽指令\n\n\nExcCode_In\nI\n5\n记录异常类型\n\n\nHWInt\nI\n6\n输入中断信号\n\n\nEXL_Clr\nI\n1\n用来复位 EXL\n\n\nEPC_Out\nO\n32\nEPC 的值\n\n\nReq\nO\n1\n进入处理程序请求\n\n\n11、Bridge该模块主要实现CPU模块和外设、Timer模块的信息交流，使用组合逻辑来实现，功能较为简单，但由于其接口较多，代码较长，这里就不详细介绍了。\n（二）测试方案参照实验教程，利用Mars实现程序的验证，通过ISE仿真输出和Mars运行流程，匹配仿真输出和Mars行为来判断当前功能是否正确。根据教程提供的p7_testcode.txt，将其翻译为对应的MIPS代码：\nadd $28, $0, $0add $29, $0, $0add $30, $0, $0add $31, $0, $0ori $28, $28, 4nopnop……nopnopnopnop\n\n然后使用魔改版Mars进行预期输出，与Verilog仿真输出比较，在不看时间并忽略对$0写入的输出的情况下，二者输出相同，故可以初步判断CPU功能正确性。\n接着利用往年学长的对拍评测机与同学进行大量对拍验证，经过对拍，二人输出保持相同，可以认为CPU基本没有问题。\n二、思考题1、当键盘、鼠标有输入时，其内部程序会产生相应的中断信号，这个中断信号输入给CPU后，CPU会识别中断的种类，然后实现相应的处理代码来处理输入数据。\n2、CPU 处理中断异常规定为已经指定好的地址，可以确保中断异常处理的统一性，实现特权级隔离，便于我们识别此时CPU是正常执行还是在处理中断异常，同时，这样设计可以让硬件实现具有简洁性和确定性。我认为还能提供我们所希望的功能，但是由于用户自定义入口，会导致不同入口的中断异常处理程序不一样，不具备统一性，导致不同的用户的CPU无法兼容运行，例如用户A的入口为0x4180，用户B的入口却为0x4680，这就会导致用户A在用用户B的入口处理中断异常时可能会出错。\n3、因为外设的种类很多，输入信息也多种多样，而我们的CPU的作用是用来处理特定数据的，使用Bridge来与外设通信，一方面可以处理不同种类外设的不同数据，让CPU只专注于处理数据执行指令的功能，另一方面还能在新增外设时，只更改Bridge中数据的中转处理，而无需修改CPU。\n4、ctrl[2:1] == 1&#39;b0用于在倒计时结束后，产生持续稳定的 Timer 中断信号；而ctrl[2:1] == 1&#39;b1用于每个一段固定的时间，产生 1 个周期的 Timer 中断信号。第一种模式的状态转移图：\n\n\n5、这会导致写入EPC的迫害指令的地址为空，导致在中断异常处理程序处理完后回到PC为空的位置而无法回到真正的迫害指令的地址。因此，在清空流水线产生的空泡指令时应该保留原有指令的PC值和对应的BD_In，确保存入EPC正常和返回现场正常。\n6、因为jalr $31, $31总跳转来看它需要跳转到31号寄存器中的地址，但是从链接来看，它又需要往31号寄存器中写入当前PC+8，如果延迟槽中的指令出现中断异常，在处理完会到现场后，继续执行jalr时由于之前已经修改了31号寄存器中的值，将无法跳转至原来希望的地址。\n","categories":["专业课"],"tags":["CO"]}]