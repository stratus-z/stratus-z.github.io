[{"title":"Hello World","url":"/2025/08/07/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"8.8更新日志","url":"/2025/08/08/8-8%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/","content":"2025年8月8日更新日志：\n\n部署评论系统\n\n","tags":["更新日志"]},{"title":"2025-BUAA-OOpre 反思与总结","url":"/2025/12/09/2025-BUAA-OOpre-%E5%8F%8D%E6%80%9D%E4%B8%8E%E6%80%BB%E7%BB%93/","content":"一、有关代码的总结1、作业最终的架构设计在经过一系列的迭代和调整后，本人的作业最终的架构设计为：\n\n下面我将结合这张IDEA自动生成的关系图来详细讲解我的最终架构。\n物品系统：\nItem：所有物品的接口，定义了所有物品的共同行为，Equipment和Bottle都实现了这个接口\n\nEquipment：装备类，定义了装备所具有的共同属性和共同行为\n\nWeapon：武器类，继承自Equipment\nSword：剑，继承自Weapon\nMagicbook：魔法书，继承自Weapon\n\n\nArmour：装甲类，继承自Equipment\n\n\nBottle：药水类，定义了药水所具备的共同属性和共同行为\n\nDefBottle\nManaBottle\nAtkBottle\nHpBottle\n\n\n\n法术系统：\nSpell：法术类，定义了所有法术的共同属性和行为\n\nHealSpell\nAttackSpell\n\n角色系统：\nAdventurer：冒险者类，实现了Employer和Employee两个接口，表明一个冒险者既可以是别人的雇主，也可以是别人的雇员\n基础模块：\nMainClass：处理输入，将输入处理为数组并传入Games启动游戏\nGames：核心模块，根据处理后的输入依次处理指令，并执行相关操作\nFactory：工厂类，用于创建所需的Item\nLexer：词法分析类，用于处理lr指令中操作\n程序的入口在MainClass类中，通过该类启动程序并输入操作指令，然后通过核心模块Games处理输入，调用方法，实现游戏功能。\n2、迭代中的架构调整及考虑第一次迭代此次迭代是在原有基础上为冒险者增加一些属性，并新增背包系统，丰富药水瓶的种类。因此，在这次迭代中引入了继承机制，便于对药水的管理。而对于背包系统，我则是选择在物品属性中新增Usable并添加相关管理方法，这也为后期的大重构埋下了伏笔。\n第二次迭代这次迭代加入了战斗机制，丰富了装备种类，并对背包系统进行了完善。其中，加入战斗机制只需要添加相应的方法即可，丰富装备种类也只是继承，而完善背包系统却导致了整个代码的大重构，其中很大的原因是由于第一次迭代的偷懒。这次迭代的重构我将原来用于存储所有冒险者的ArrayList容器改成了HashMap，同时在冒险者类中加入了完整的背包系统，其中的药水栏借助队列Queue实现。但在这次重构中，由于我的疏忽，并未对背包实现完整的管理，导致程序出现bug，没有通过强测。\n第三次迭代第三次迭代要求加入雇佣关系和相关限制，并引入了观察者模式。在引入雇佣关系限制的时候，最关键的一点在于异常指令判断与雇佣关系限制判断的优先级。引入的观察者模式则可以非常自然的实现救援这一过程。\n第四次迭代这次迭代只新增了lr指令，但是我们需要使用递归下降的思想来实现指令的正则化处理。在这次迭代中，我选择使用递归来实现多重关系的导入。\n二、使用JUnit的心得体会使用JUnit的目的是来测试我们自己编写的代码功能是否正常，而作业中对JUnit有着覆盖率的要求，这在很大程度上促使我们去更加全面的测试自己的代码。一方面，方法覆盖率需要我们尽可能的将所有的方法都覆盖，也就是说我们要尽可能全面的测试所有类型的指令；另一方面，分支覆盖率提醒我们要考虑到每一条指令的多种情况，这在很大程度上帮我测出了一些潜在的bug。在写JUnit测试的过程中，我也体会到，通过测试顶层的方法，它能够调用下层方法并覆盖，因此在写测试时，我们应优先测试顶层方法，然后再逐步完善测试未被覆盖的方法。同时，在编写JUnit代码中的一次重复度较高的部分，我尝试利用C语言程序简单实现了测试指令自动化转测试代码，这在一定程度上加快了我的JUnit代码的编写。\n三、学习OOPre的心得体会学习OOPre的过程并没有想象中的那么难，其关键在于编程思想的转变。之前面向过程编程侧重于算法和步骤，基本单位是函数，而面向过程编程则侧重于数据和关系，基本单位是类，这一转变让我能更好的专注于程序的功能，而不是它是怎么实现的，通过类的封装，我们只要把那些方法当成黑箱即可。\n同时，面向对象里的继承机制极大的方便了对于不同对象的处理，也更能清晰的展示不同对象之间的关系。在学习OOPre的过程中，我们也学习了一些模式如工厂模式、观察者模式等，这些不同的模式有着各自擅长处理的方法和使用场景，通过选用合适的模式，我们的程序逻辑可以更加清晰，功能也不容易出错。除此之外，面向对象的编程模式让我们更加方便添加新的功能和方法，这是因为面向对象是抽象建模的过程，在添加新功能迭代的时候，我们可以直接按照人的思维来实现。\n在编写作业程序时，我们封装了多个类，每个类各行其职，代码的整体逻辑十分明了。在编写核心程序的过程就像是搭积木，把其他类的方法按照逻辑依次调用，“拼装”成我们想要的程序。还让我感触很深的一点就是，对于之前从未接触过的Java语言，上手竟然如此容易，这也验证编程的关键不在于编程语言，而在于编程的思维。而且，借助编译器自带的代码提示工具，我们上手一门陌生编程语言的门槛越来越低。\n四、对OOPre课程的简单建议\n建议在Pre课程开始前提供一点Pre的Pre，比如简单Java程序设计，帮助大家提前适应Java编程。\n建议JUnit的教程可以再详细一点\n\n","categories":["专业课"],"tags":["OO","反思总结"]}]