[{"title":"Hello World","url":"/2025/08/07/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"8.8更新日志","url":"/2025/08/08/8-8%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/","content":"2025年8月8日更新日志：\n\n部署评论系统\n\n","tags":["更新日志"]},{"title":"2025-BUAA-OOpre 反思与总结","url":"/2025/12/09/2025-BUAA-OOpre-%E5%8F%8D%E6%80%9D%E4%B8%8E%E6%80%BB%E7%BB%93/","content":"一、有关代码的总结1、作业最终的架构设计在经过一系列的迭代和调整后，本人的作业最终的架构设计为：\n\n下面我将结合这张IDEA自动生成的关系图来详细讲解我的最终架构。\n物品系统：\nItem：所有物品的接口，定义了所有物品的共同行为，Equipment和Bottle都实现了这个接口\n\nEquipment：装备类，定义了装备所具有的共同属性和共同行为\n\nWeapon：武器类，继承自Equipment\nSword：剑，继承自Weapon\nMagicbook：魔法书，继承自Weapon\n\n\nArmour：装甲类，继承自Equipment\n\n\nBottle：药水类，定义了药水所具备的共同属性和共同行为\n\nDefBottle\nManaBottle\nAtkBottle\nHpBottle\n\n\n\n法术系统：\nSpell：法术类，定义了所有法术的共同属性和行为\n\nHealSpell\nAttackSpell\n\n角色系统：\nAdventurer：冒险者类，实现了Employer和Employee两个接口，表明一个冒险者既可以是别人的雇主，也可以是别人的雇员\n基础模块：\nMainClass：处理输入，将输入处理为数组并传入Games启动游戏\nGames：核心模块，根据处理后的输入依次处理指令，并执行相关操作\nFactory：工厂类，用于创建所需的Item\nLexer：词法分析类，用于处理lr指令中操作\n程序的入口在MainClass类中，通过该类启动程序并输入操作指令，然后通过核心模块Games处理输入，调用方法，实现游戏功能。\n2、迭代中的架构调整及考虑第一次迭代此次迭代是在原有基础上为冒险者增加一些属性，并新增背包系统，丰富药水瓶的种类。因此，在这次迭代中引入了继承机制，便于对药水的管理。而对于背包系统，我则是选择在物品属性中新增Usable并添加相关管理方法，这也为后期的大重构埋下了伏笔。\n第二次迭代这次迭代加入了战斗机制，丰富了装备种类，并对背包系统进行了完善。其中，加入战斗机制只需要添加相应的方法即可，丰富装备种类也只是继承，而完善背包系统却导致了整个代码的大重构，其中很大的原因是由于第一次迭代的偷懒。这次迭代的重构我将原来用于存储所有冒险者的ArrayList容器改成了HashMap，同时在冒险者类中加入了完整的背包系统，其中的药水栏借助队列Queue实现。但在这次重构中，由于我的疏忽，并未对背包实现完整的管理，导致程序出现bug，没有通过强测。\n第三次迭代第三次迭代要求加入雇佣关系和相关限制，并引入了观察者模式。在引入雇佣关系限制的时候，最关键的一点在于异常指令判断与雇佣关系限制判断的优先级。引入的观察者模式则可以非常自然的实现救援这一过程。\n第四次迭代这次迭代只新增了lr指令，但是我们需要使用递归下降的思想来实现指令的正则化处理。在这次迭代中，我选择使用递归来实现多重关系的导入。\n二、使用JUnit的心得体会使用JUnit的目的是来测试我们自己编写的代码功能是否正常，而作业中对JUnit有着覆盖率的要求，这在很大程度上促使我们去更加全面的测试自己的代码。一方面，方法覆盖率需要我们尽可能的将所有的方法都覆盖，也就是说我们要尽可能全面的测试所有类型的指令；另一方面，分支覆盖率提醒我们要考虑到每一条指令的多种情况，这在很大程度上帮我测出了一些潜在的bug。在写JUnit测试的过程中，我也体会到，通过测试顶层的方法，它能够调用下层方法并覆盖，因此在写测试时，我们应优先测试顶层方法，然后再逐步完善测试未被覆盖的方法。同时，在编写JUnit代码中的一次重复度较高的部分，我尝试利用C语言程序简单实现了测试指令自动化转测试代码，这在一定程度上加快了我的JUnit代码的编写。\n三、学习OOPre的心得体会学习OOPre的过程并没有想象中的那么难，其关键在于编程思想的转变。之前面向过程编程侧重于算法和步骤，基本单位是函数，而面向过程编程则侧重于数据和关系，基本单位是类，这一转变让我能更好的专注于程序的功能，而不是它是怎么实现的，通过类的封装，我们只要把那些方法当成黑箱即可。\n同时，面向对象里的继承机制极大的方便了对于不同对象的处理，也更能清晰的展示不同对象之间的关系。在学习OOPre的过程中，我们也学习了一些模式如工厂模式、观察者模式等，这些不同的模式有着各自擅长处理的方法和使用场景，通过选用合适的模式，我们的程序逻辑可以更加清晰，功能也不容易出错。除此之外，面向对象的编程模式让我们更加方便添加新的功能和方法，这是因为面向对象是抽象建模的过程，在添加新功能迭代的时候，我们可以直接按照人的思维来实现。\n在编写作业程序时，我们封装了多个类，每个类各行其职，代码的整体逻辑十分明了。在编写核心程序的过程就像是搭积木，把其他类的方法按照逻辑依次调用，“拼装”成我们想要的程序。还让我感触很深的一点就是，对于之前从未接触过的Java语言，上手竟然如此容易，这也验证编程的关键不在于编程语言，而在于编程的思维。而且，借助编译器自带的代码提示工具，我们上手一门陌生编程语言的门槛越来越低。\n四、对OOPre课程的简单建议\n建议在Pre课程开始前提供一点Pre的Pre，比如简单Java程序设计，帮助大家提前适应Java编程。\n建议JUnit的教程可以再详细一点\n\n","categories":["专业课"],"tags":["OO","反思总结"]},{"title":"P3_CPU设计文档","url":"/2026/02/06/P3-CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/","content":"一、CPU设计文档（一）设计草稿本次CPU搭建需要实现的指令有add, sub, ori, lw, sw, beq, lui, nop，而CPU的构成模块有IFU, GRF, ALU, DM, EXT, Controller, NPC, Splitter，其中EXT和Splitter可以有Logisim自带的元件实现，而其他的模块则需要我们自己搭建。\n在要实现的指令中，I型指令有 ori, lw, sw, beq, lui：\n\n\n\nOpCode\nrs\nrt\nimm16\n\n\n\n6\n5\n5\n16\n\n\nR型指令有add, sub, nop：\n\n\n\nOpCode\nrs\nrt\nrd\nshamt\nFunct\n\n\n\n6\n5\n5\n5\n5\n6\n\n\n没有J型指令。\n1、IFU按照教程要求，IFU内部包括PC和IM的功能，其中PC用寄存器实现，并需要具有异步复位至0x00003000的功能，IM则要求容量为4096 × 32bit。\n对于IM，它保存的内容时待执行代码的二进制码，因此用ROM来实现，由于PC的起始地址为0x00003000，且相邻两条地址相差为4，因此地址PC与ROM中指令地址的对应关系如下：\n\n因此IM的电路为：\n\n\n对于PC，它的设计关键在于如何处理异步复位时将地址复位至0x00003000，根据逻辑表达式a ^ b ^ a = b和a ^ 0 = a，我们可以利用异或门来实现异步复位至0x00003000的操作：\n\n\n将PC和IM合并后的IFU的外观为：\n\n\n端口的说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nNPC\nI\n32\nNPC模块输出的下一条指令的地址\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n异步复位信号\n\n\nInstr\nO\n32\nIM取出的指令\n\n\nPC\nO\n32\n当前指令地址\n\n\n2、GRFGRF是通用寄存器组，其功能描述与P0时的GRF如出一辙，因此我选择调整之前P0的GRF的外观，并将其导入本次的CPU中作为现成的模块。调整后的外观为：\n\n\n端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nA1\nI\n5\n读寄存器1的地址\n\n\nA2\nI\n5\n读寄存器2的地址\n\n\nWriteAddress\nI\n5\n写入寄存器的地址\n\n\nWriteData\nI\n32\n写入寄存器的数据\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n异步复位信号\n\n\nWE\nI\n1\n写入使能信号\n\n\nRD1\nO\n32\n读寄存器1的数据\n\n\nRD2\nO\n32\n读寄存器2的数据\n\n\n3、ALUALU作为算术逻辑单元需要实现加、减、或运算和比较大小的功能，这些功能可以通过多路选择器来实现选择输出，其中比较大小功能是在输入的两个数相等时输出1，因此为其单独设计一个输出口beq。用于选择运算的ALU_op为两位，000时选择加法运算，001时选择减法运算，010时选择或运算，其他时上方out输出为x，只有beq输出，同时便于后续扩展。按照此逻辑，设计出来的ALU模块为：\n\n\n端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nin1\nI\n32\n输入待操作数1\n\n\nin2\nI\n32\n输入待操作数2\n\n\nALU_op\nI\n3\nALU控制信号\n\n\nout\nO\n32\n运算结果\n\n\nbeq\nO\n1\n两个待操作数是否相等\n\n\n4、NPCNPC模块是根据当前地址和操作，处理得到下一条指令的地址。根据相邻两条地址相差4，如果指令中没有转跳，下一条指令地址即为当前地址加4，否则，如果为beq转跳，还要加上指令跳转的相对偏移量imm16。设计出来的NPC模块外观为：\n\n\n端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nPC\nI\n32\n当前指令地址\n\n\noffset\nI\n16\n跳转的相对偏移量\n\n\nrj\nI\n1\n1表示要跳转，0表示不要\n\n\nNPC\nO\n32\n下一条指令地址\n\n\n5、DMDM模块使用了Logisim自带的RAM来实现，通过输入输出端口分离的设置来实现既读取又写入的功能，并保证了异步复位的功能。设计好后的模块为：\n\n\n端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nAddr\nI\n32\n写入或读取的地址\n\n\nWD\nI\n32\n写入的数据\n\n\nWR\nI\n1\n0表示读，1表示写\n\n\nclk\nI\n1\n时钟信号\n\n\nreset\nI\n1\n异步复位信号\n\n\nRD\nO\n32\n读取的数据\n\n\n6、ControllerController模块用于处理当前的指令类型，并输出控制信息，协调其他模块一起实现指令要求的功能。根据实验教程的提示，我将该模块拆分为AND_Logic模块和OR_Logic模块。其中，AND_Logic模块用于根据机器码判断当前指令是什么，而OR_Logic模块用于输出对应指令需要调用的模块信息。\nAND_Logic模块中，我使用了大量Tunnel来辅助连线，而不是像教程一样直接连线，我用_n来标记信号为原信号取反的信号，我认为这样处理可以逻辑更清晰，不易出错，且下次添加指令也较为方便。AND_Logic模块的外观为：\n\n\nOR_Logic模块则大体与教程相同，将两个模块结合起来，就形成了我们的Controller模块：\n\n\n其端口说明为：\n\n\n\n信号名\n方向\n位宽\n说明\n\n\n\nFunct\nI\n6\n输入Instr[5:0]\n\n\nOpCode\nI\n6\n输入Instr[31:26]\n\n\nRegDst\nO\n1\nGRF写选择信号，0表示rt，1表示rd\n\n\nALUSrc\nO\n1\nALU输入信号选择，0表示in2为RD2，1表示in2为扩展后的imm16\n\n\nMemtoReg\nO\n1\nGRF输入信号选择，1表示来自DM\n\n\nRegWrite\nO\n1\nGRF写使能信号\n\n\nMemWrite\nO\n1\nDM读写使能信号\n\n\nnPC_sel\nO\n1\n1表示当前指令为beq\n\n\nExtOp\nO\n1\n扩展选择信号，0为零扩展，1为符号扩展\n\n\nALU_op\nO\n3\nALU的操作码\n\n\n（二）测试方案目前的测试方案参照实验教程，利用Mars实现程序的验证，通过Logisim和Mars同时逐步运行某一程序，并核对DM、GRF中的值是否与Mars中匹配来判断当前功能是否正确。强度更大的自动化测试还在探索中，希望能够通过自动化的程序生成强度更大的测试样例，并实现自动核对。\n二、思考题1、单周期CPU所用到的模块中，发挥状态存储功能的是PC寄存器、GRF、DM、ROM，发挥状态转移功能的是Splitter、Controller、ALU、NPC、MUX和EXT。\n2、合理。IM是指令存储器，指令一般是只读的二进制码，使用ROM可以确保指令不被修改；DM是数据存储器，既需要读也需要写，使用RAM可以满足既读又写的需求；GRF是寄存器堆，在读写时对速度要求较高，使用寄存器可以提供较高的读写速度。\n3、除上述提示模块外，我还设计了NPC模块，用于实现指令地址转移的组合逻辑。在程序中，两条相邻指令地址差为4，因此要得到下一条指令的地址，首先要将当前指令加4，如果没有出现跳转指令，则结果就是下一条指令的地址，如果当前指令为beq且需要跳转，根据指令集中对beq的操作描述，下一条指令地址为PC + 4 + sign_extend(offset||00)，利用Splitter和Bit Extender便可以实现这一操作。然后使用多路选择器，选择信号为1位的rj，表示是否需要相对跳转，来选择下一条指令的地址是否需要加上offset。\n4、nop为空指令，实际上不需要任何操作，既不会改变GRF中寄存器的值，又不需要对DM进行读写操作，我们只需要保证在指令为nop时，GRF和DM模块均不会进行写入操作，便能实现空指令行为。因此，即使不把nop加入控制信号真值表，所有的写入信号均为0，CPU并不会执行任何写入操作。\n5、这些测试样例虽然基本覆盖了要测试的指令，但还缺少sub、beq指令的测试，同时其测试强度也不足。首先，这些测试样例没有覆盖所有的极端数据，也没有覆盖所有的寄存器，情况覆盖率不够；其次，这个样例指令数量比较少，数据强度不够大，不能判断多次累计运算后功能是否还正常。\n","categories":["专业课"],"tags":["CO"]}]